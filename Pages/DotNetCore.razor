@page "/dotnetcore"

<TabControl>
    <TabPage Title=".NET Core concepts">
        <div class="content">
            <h2>🧩 <strong>.NET Core Concepts (Complete List)</strong></h2>
            <h3>🟢 <strong>1. Basics of .NET Core</strong></h3>
            <p>These are the foundational building blocks you need to understand before diving into advanced features.</p>
            <h4>🔹 Core Concepts</h4>
            <ul>
                <li>
                    <p>What is <strong>.NET Core</strong> vs <strong>.NET Framework</strong> vs <strong>.NET 5/6/7/8+</strong></p>
                </li>
                <li>
                    <p><strong>CLR (Common Language Runtime)</strong></p>
                </li>
                <li>
                    <p><strong>BCL (Base Class Library)</strong></p>
                </li>
                <li>
                    <p><strong>CTS (Common Type System)</strong></p>
                </li>
                <li>
                    <p><strong>CLS (Common Language Specification)</strong></p>
                </li>
                <li>
                    <p><strong>Managed Code vs Unmanaged Code</strong></p>
                </li>
                <li>
                    <p><strong>Assemblies</strong> and <strong>Namespaces</strong></p>
                </li>
                <li>
                    <p><strong>NuGet Packages</strong> and Package Management</p>
                </li>
                <li>
                    <p><strong>Project Structure</strong> (<code>.csproj</code>, <code>Program.cs</code>, <code>Startup.cs</code>)</p>
                </li>
                <li>
                    <p><strong>Cross-platform Development</strong> (Windows, Linux, macOS)</p>
                </li>
                <li>
                    <p><strong>SDK &amp; Runtime</strong></p>
                </li>
            </ul>
            <hr />
            <h3>🟡 <strong>2. C# and Object-Oriented Programming</strong></h3>
            <p>Understanding C# is essential for .NET Core development.</p>
            <h4>🔹 C# Fundamentals</h4>
            <ul>
                <li>
                    <p>Data Types, Variables, Operators</p>
                </li>
                <li>
                    <p>Control Statements (<code>if</code>, <code>switch</code>, <code>loops</code>)</p>
                </li>
                <li>
                    <p>Arrays, Strings, Collections, Generics</p>
                </li>
                <li>
                    <p>Methods and Parameters</p>
                </li>
                <li>
                    <p>Exception Handling</p>
                </li>
            </ul>
            <h4>🔹 OOP Concepts in C#</h4>
            <ul>
                <li>
                    <p>Class &amp; Object</p>
                </li>
                <li>
                    <p>Abstraction</p>
                </li>
                <li>
                    <p>Encapsulation</p>
                </li>
                <li>
                    <p>Inheritance</p>
                </li>
                <li>
                    <p>Polymorphism</p>
                </li>
                <li>
                    <p>Interfaces &amp; Abstract Classes</p>
                </li>
                <li>
                    <p>Constructors / Destructors</p>
                </li>
                <li>
                    <p>Access Modifiers</p>
                </li>
                <li>
                    <p>Static Members</p>
                </li>
                <li>
                    <p>Structs and Enums</p>
                </li>
            </ul>
            <hr />
            <h3>🟠 <strong>3. Intermediate .NET Core Concepts</strong></h3>
            <p>These concepts introduce how .NET Core applications are structured and run.</p>
            <h4>🔹 Core Runtime &amp; Execution</h4>
            <ul>
                <li>
                    <p>JIT (Just-In-Time) Compilation</p>
                </li>
                <li>
                    <p>Garbage Collection (GC)</p>
                </li>
                <li>
                    <p>Dependency Injection (DI)</p>
                </li>
                <li>
                    <p>Configuration and Options Pattern</p>
                </li>
                <li>
                    <p>Logging (via <code>ILogger</code>)</p>
                </li>
                <li>
                    <p>Middleware and the Request Pipeline</p>
                </li>
                <li>
                    <p>Hosting Models (Kestrel, IIS)</p>
                </li>
                <li>
                    <p>Environment Variables and <code>IWebHostEnvironment</code></p>
                </li>
            </ul>
            <h4>🔹 Data Handling</h4>
            <ul>
                <li>
                    <p>File I/O</p>
                </li>
                <li>
                    <p>Serialization (JSON, XML)</p>
                </li>
                <li>
                    <p>Model Binding and Validation</p>
                </li>
                <li>
                    <p>Working with DTOs and ViewModels</p>
                </li>
            </ul>
            <hr />
            <h3>🔵 <strong>4. ASP.NET Core (Web Development)</strong></h3>
            <p>.NET Core is often used for building modern web apps and APIs.</p>
            <h4>🔹 Web Application Basics</h4>
            <ul>
                <li>
                    <p>MVC (Model&ndash;View&ndash;Controller) Pattern</p>
                </li>
                <li>
                    <p>Razor Pages and Views</p>
                </li>
                <li>
                    <p>Tag Helpers</p>
                </li>
                <li>
                    <p>Layouts and Partial Views</p>
                </li>
            </ul>
            <h4>🔹 Web API</h4>
            <ul>
                <li>
                    <p>Creating RESTful APIs</p>
                </li>
                <li>
                    <p>Routing and Attribute Routing</p>
                </li>
                <li>
                    <p>Model Binding and Validation</p>
                </li>
                <li>
                    <p>Filters (Action, Authorization, Exception)</p>
                </li>
                <li>
                    <p>Content Negotiation (JSON, XML)</p>
                </li>
                <li>
                    <p>Swagger / OpenAPI Integration</p>
                </li>
            </ul>
            <h4>🔹 State Management</h4>
            <ul>
                <li>
                    <p>Sessions, Cookies</p>
                </li>
                <li>
                    <p>TempData, ViewData, ViewBag</p>
                </li>
            </ul>
            <h4>🔹 Security</h4>
            <ul>
                <li>
                    <p>Authentication &amp; Authorization (Identity)</p>
                </li>
                <li>
                    <p>JWT (JSON Web Tokens)</p>
                </li>
                <li>
                    <p>Policy-based and Role-based Authorization</p>
                </li>
                <li>
                    <p>Data Protection API</p>
                </li>
                <li>
                    <p>HTTPS and CORS</p>
                </li>
            </ul>
            <hr />
            <h3>🟣 <strong>5. Data Access</strong></h3>
            <h4>🔹 Entity Framework Core (EF Core)</h4>
            <ul>
                <li>
                    <p>DbContext and DbSet</p>
                </li>
                <li>
                    <p>Code-First and Database-First approaches</p>
                </li>
                <li>
                    <p>LINQ (Language Integrated Query)</p>
                </li>
                <li>
                    <p>Migrations</p>
                </li>
                <li>
                    <p>CRUD Operations</p>
                </li>
                <li>
                    <p>Relationships (One-to-One, One-to-Many, Many-to-Many)</p>
                </li>
                <li>
                    <p>Lazy, Eager, and Explicit Loading</p>
                </li>
                <li>
                    <p>Repository and Unit of Work Patterns</p>
                </li>
            </ul>
            <h4>🔹 Alternative Data Access</h4>
            <ul>
                <li>
                    <p>ADO.NET</p>
                </li>
                <li>
                    <p>Dapper (Micro ORM)</p>
                </li>
            </ul>
            <hr />
            <h3>🔴 <strong>6. Advanced .NET Core Concepts</strong></h3>
            <p>Now we get into professional-level and enterprise topics.</p>
            <h4>🔹 Advanced Architecture &amp; Design</h4>
            <ul>
                <li>
                    <p>SOLID Principles</p>
                </li>
                <li>
                    <p>Dependency Injection (DI) Patterns</p>
                </li>
                <li>
                    <p>Middleware Customization</p>
                </li>
                <li>
                    <p>Clean Architecture / Onion Architecture</p>
                </li>
                <li>
                    <p>Domain-Driven Design (DDD)</p>
                </li>
                <li>
                    <p>CQRS (Command Query Responsibility Segregation)</p>
                </li>
                <li>
                    <p>Event-Driven Architecture</p>
                </li>
            </ul>
            <h4>🔹 Asynchronous Programming</h4>
            <ul>
                <li>
                    <p>Async and Await</p>
                </li>
                <li>
                    <p>Task Parallel Library (TPL)</p>
                </li>
                <li>
                    <p>Background Services &amp; Hosted Services</p>
                </li>
                <li>
                    <p>IHostedService and BackgroundWorker</p>
                </li>
            </ul>
            <h4>🔹 Configuration &amp; Deployment</h4>
            <ul>
                <li>
                    <p>Environment Configuration (appsettings.json, appsettings.Development.json)</p>
                </li>
                <li>
                    <p>Logging Providers (Console, Debug, Serilog, NLog, etc.)</p>
                </li>
                <li>
                    <p>Docker Containerization</p>
                </li>
                <li>
                    <p>CI/CD (GitHub Actions, Azure DevOps, etc.)</p>
                </li>
                <li>
                    <p>Publishing and Deployment (Azure, AWS, Linux)</p>
                </li>
            </ul>
            <h4>🔹 Caching &amp; Performance</h4>
            <ul>
                <li>
                    <p>In-Memory Caching</p>
                </li>
                <li>
                    <p>Distributed Caching (Redis, SQL Server)</p>
                </li>
                <li>
                    <p>Response Caching</p>
                </li>
                <li>
                    <p>Output Caching (ASP.NET Core 8+)</p>
                </li>
                <li>
                    <p>Performance Profiling and Optimization</p>
                </li>
            </ul>
            <h4>🔹 Testing</h4>
            <ul>
                <li>
                    <p>Unit Testing (xUnit, NUnit, MSTest)</p>
                </li>
                <li>
                    <p>Integration Testing</p>
                </li>
                <li>
                    <p>Mocking (Moq)</p>
                </li>
                <li>
                    <p>Test-driven Development (TDD)</p>
                </li>
            </ul>
            <h4>🔹 Globalization &amp; Localization</h4>
            <ul>
                <li>
                    <p>Resource Files (<code>.resx</code>)</p>
                </li>
                <li>
                    <p>CultureInfo and Localization Middleware</p>
                </li>
            </ul>
            <h4>🔹 Security (Advanced)</h4>
            <ul>
                <li>
                    <p>OAuth 2.0 / OpenID Connect</p>
                </li>
                <li>
                    <p>IdentityServer</p>
                </li>
                <li>
                    <p>External Logins (Google, Facebook, Microsoft)</p>
                </li>
                <li>
                    <p>Custom Authentication Handlers</p>
                </li>
            </ul>
            <hr />
            <h3>⚫ <strong>7. Cloud &amp; Microservices</strong></h3>
            <h4>🔹 Microservices Architecture</h4>
            <ul>
                <li>
                    <p>Building Microservices in .NET Core</p>
                </li>
                <li>
                    <p>API Gateway (Ocelot, YARP)</p>
                </li>
                <li>
                    <p>Communication between services (REST, gRPC, Message Queues)</p>
                </li>
                <li>
                    <p>Service Discovery (Consul, Eureka)</p>
                </li>
                <li>
                    <p>Distributed Tracing (Jaeger, OpenTelemetry)</p>
                </li>
            </ul>
            <h4>🔹 Cloud Integration</h4>
            <ul>
                <li>
                    <p>Azure App Services</p>
                </li>
                <li>
                    <p>Azure Functions (Serverless)</p>
                </li>
                <li>
                    <p>Azure Key Vault</p>
                </li>
                <li>
                    <p>Azure Storage (Blob, Queue, Table)</p>
                </li>
                <li>
                    <p>AWS Lambda with .NET Core</p>
                </li>
            </ul>
            <hr />
            <h3>⚪ <strong>8. Modern Topics</strong></h3>
            <h4>🔹 Minimal APIs (ASP.NET Core 6+)</h4>
            <ul>
                <li>
                    <p>Lightweight endpoint-based APIs</p>
                </li>
                <li>
                    <p>Comparison with MVC</p>
                </li>
                <li>
                    <p>Endpoint Filters</p>
                </li>
            </ul>
            <h4>🔹 Blazor</h4>
            <ul>
                <li>
                    <p>Blazor Server vs Blazor WebAssembly</p>
                </li>
                <li>
                    <p>Components and Data Binding</p>
                </li>
                <li>
                    <p>Event Handling and Dependency Injection</p>
                </li>
            </ul>
            <h4>🔹 gRPC</h4>
            <ul>
                <li>
                    <p>High-performance RPC framework</p>
                </li>
                <li>
                    <p>Proto files and code generation</p>
                </li>
                <li>
                    <p>Streaming and Channels</p>
                </li>
            </ul>
            <h4>🔹 Worker Services</h4>
            <ul>
                <li>
                    <p>Background processing apps</p>
                </li>
                <li>
                    <p>Hosted services and long-running tasks</p>
                </li>
            </ul>
            <h4>🔹 SignalR</h4>
            <ul>
                <li>
                    <p>Real-time communication (e.g., chat apps, live dashboards)</p>
                </li>
            </ul>
            <hr />
            <h2>✅ <strong>Summary &mdash; .NET Core Concepts Roadmap</strong></h2>
            <table>
                <thead>
                    <tr>
                        <th>Level</th>
                        <th>Key Topics</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>🟢 <strong>Basic</strong></td>
                        <td>CLR, BCL, Assemblies, Data Types, OOP</td>
                    </tr>
                    <tr>
                        <td>🟡 <strong>Intermediate</strong></td>
                        <td>Middleware, DI, Configuration, EF Core</td>
                    </tr>
                    <tr>
                        <td>🔵 <strong>Web Development</strong></td>
                        <td>MVC, Web API, Razor, Security</td>
                    </tr>
                    <tr>
                        <td>🟣 <strong>Data Access</strong></td>
                        <td>EF Core, LINQ, Migrations, Dapper</td>
                    </tr>
                    <tr>
                        <td>🔴 <strong>Advanced</strong></td>
                        <td>Async, Clean Architecture, Docker, CI/CD</td>
                    </tr>
                    <tr>
                        <td>⚫ <strong>Microservices / Cloud</strong></td>
                        <td>gRPC, Azure, Message Queues, API Gateway</td>
                    </tr>
                    <tr>
                        <td>⚪ <strong>Modern .NET</strong></td>
                        <td>Minimal APIs, Blazor, SignalR, Worker Services</td>
                    </tr>
                </tbody>
            </table>
            <hr />
        </div>
    </TabPage>
    <TabPage Title="Concise summary">
        <div class="content">
            <h2>🟢 <strong>1. .NET Core Basics</strong></h2>
            <table>
                <thead>
                    <tr>
                        <th>Concept</th>
                        <th>Summary</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>.NET Core</strong></td>
                        <td>Cross-platform, open-source framework for building modern apps (Windows, Linux, macOS). Now part of unified <strong>.NET (5/6/7/8)</strong>.</td>
                    </tr>
                    <tr>
                        <td><strong>CLR (Common Language Runtime)</strong></td>
                        <td>The engine that runs .NET applications &mdash; manages memory, execution, security, and exception handling.</td>
                    </tr>
                    <tr>
                        <td><strong>BCL (Base Class Library)</strong></td>
                        <td>A collection of prebuilt classes (e.g., <code>System.IO</code>, <code>System.Net</code>) that provide fundamental functionality.</td>
                    </tr>
                    <tr>
                        <td><strong>CTS (Common Type System)</strong></td>
                        <td>Defines how data types are declared and used across .NET languages for compatibility.</td>
                    </tr>
                    <tr>
                        <td><strong>CLS (Common Language Specification)</strong></td>
                        <td>A set of rules ensuring interoperability between different .NET languages (C#, VB.NET, F#).</td>
                    </tr>
                    <tr>
                        <td><strong>Assemblies</strong></td>
                        <td>The compiled output of .NET projects (<code>.dll</code> or <code>.exe</code>) containing IL (Intermediate Language) code.</td>
                    </tr>
                    <tr>
                        <td><strong>Namespaces</strong></td>
                        <td>Logical grouping of classes for organization and to prevent naming conflicts.</td>
                    </tr>
                    <tr>
                        <td><strong>NuGet</strong></td>
                        <td>.NET package manager used to install and manage third-party or custom libraries.</td>
                    </tr>
                    <tr>
                        <td><strong>Managed vs Unmanaged Code</strong></td>
                        <td>Managed code runs under CLR supervision; unmanaged code runs directly on the OS.</td>
                    </tr>
                    <tr>
                        <td><strong>Cross-platform</strong></td>
                        <td>Apps can run on multiple operating systems using the same codebase.</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>🟡 <strong>2. C# and OOP Basics</strong></h2>
            <table>
                <thead>
                    <tr>
                        <th>Concept</th>
                        <th>Summary</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Data Types &amp; Variables</strong></td>
                        <td>Store values (int, string, bool, etc.) and are the building blocks of logic.</td>
                    </tr>
                    <tr>
                        <td><strong>Control Structures</strong></td>
                        <td>Conditional and looping constructs (<code>if</code>, <code>switch</code>, <code>for</code>, <code>while</code>) for controlling program flow.</td>
                    </tr>
                    <tr>
                        <td><strong>Exception Handling</strong></td>
                        <td>Mechanism (<code>try</code>, <code>catch</code>, <code>finally</code>) to handle runtime errors gracefully.</td>
                    </tr>
                    <tr>
                        <td><strong>Class &amp; Object</strong></td>
                        <td>A class defines a blueprint; objects are instances of classes.</td>
                    </tr>
                    <tr>
                        <td><strong>Encapsulation</strong></td>
                        <td>Hides internal details of a class using access modifiers and exposes controlled interfaces.</td>
                    </tr>
                    <tr>
                        <td><strong>Abstraction</strong></td>
                        <td>Hides implementation details and shows only essential functionality.</td>
                    </tr>
                    <tr>
                        <td><strong>Inheritance</strong></td>
                        <td>Enables one class to derive behavior and data from another.</td>
                    </tr>
                    <tr>
                        <td><strong>Polymorphism</strong></td>
                        <td>Allows methods to behave differently based on the object invoking them.</td>
                    </tr>
                    <tr>
                        <td><strong>Interfaces &amp; Abstract Classes</strong></td>
                        <td>Define contracts or base structures for derived classes to implement.</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>🟠 <strong>3. Intermediate .NET Core Concepts</strong></h2>
            <table>
                <thead>
                    <tr>
                        <th>Concept</th>
                        <th>Summary</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>JIT Compilation</strong></td>
                        <td>Converts IL (Intermediate Language) code to machine code at runtime for execution.</td>
                    </tr>
                    <tr>
                        <td><strong>Garbage Collection</strong></td>
                        <td>Automatically manages memory allocation and deallocation.</td>
                    </tr>
                    <tr>
                        <td><strong>Dependency Injection (DI)</strong></td>
                        <td>Design pattern for managing object dependencies, improving flexibility and testability.</td>
                    </tr>
                    <tr>
                        <td><strong>Middleware</strong></td>
                        <td>Software components that handle requests/responses in the ASP.NET Core request pipeline.</td>
                    </tr>
                    <tr>
                        <td><strong>Configuration</strong></td>
                        <td>Managed through <code>appsettings.json</code>, environment variables, and the <code>IConfiguration</code> interface.</td>
                    </tr>
                    <tr>
                        <td><strong>Logging</strong></td>
                        <td>Uses <code>ILogger</code> to record runtime information and errors.</td>
                    </tr>
                    <tr>
                        <td><strong>Hosting Models</strong></td>
                        <td>Kestrel (built-in web server), IIS, or self-hosting using <code>WebHostBuilder</code>.</td>
                    </tr>
                    <tr>
                        <td><strong>Environment Management</strong></td>
                        <td>Define environments like Development, Staging, and Production for config isolation.</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>🔵 <strong>4. ASP.NET Core (Web Development)</strong></h2>
            <table>
                <thead>
                    <tr>
                        <th>Concept</th>
                        <th>Summary</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>MVC Pattern</strong></td>
                        <td>Separates application into Model (data), View (UI), and Controller (logic).</td>
                    </tr>
                    <tr>
                        <td><strong>Routing</strong></td>
                        <td>Defines how incoming URLs map to controllers and actions.</td>
                    </tr>
                    <tr>
                        <td><strong>Razor Pages</strong></td>
                        <td>Simplified page-based model for building web apps without full MVC structure.</td>
                    </tr>
                    <tr>
                        <td><strong>Tag Helpers</strong></td>
                        <td>Server-side components that simplify HTML generation in Razor views.</td>
                    </tr>
                    <tr>
                        <td><strong>Web API</strong></td>
                        <td>Framework for building RESTful APIs that expose data and services.</td>
                    </tr>
                    <tr>
                        <td><strong>Model Binding</strong></td>
                        <td>Automatically maps HTTP request data to action method parameters.</td>
                    </tr>
                    <tr>
                        <td><strong>Validation</strong></td>
                        <td>Ensures data correctness using attributes like <code>[Required]</code>, <code>[Range]</code>, etc.</td>
                    </tr>
                    <tr>
                        <td><strong>Filters</strong></td>
                        <td>Logic that runs before or after controller actions (authorization, exception handling, etc.).</td>
                    </tr>
                    <tr>
                        <td><strong>State Management</strong></td>
                        <td>Maintains user data across requests (Session, Cookies, TempData, ViewBag).</td>
                    </tr>
                    <tr>
                        <td><strong>Security</strong></td>
                        <td>Authentication (who you are) and Authorization (what you can do), implemented via ASP.NET Core Identity, JWT, or OAuth.</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>🟣 <strong>5. Data Access</strong></h2>
            <table>
                <thead>
                    <tr>
                        <th>Concept</th>
                        <th>Summary</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Entity Framework Core (EF Core)</strong></td>
                        <td>ORM that simplifies database operations using C# objects.</td>
                    </tr>
                    <tr>
                        <td><strong>DbContext / DbSet</strong></td>
                        <td>Represent the database and tables in EF Core.</td>
                    </tr>
                    <tr>
                        <td><strong>LINQ</strong></td>
                        <td>Query language integrated into C# for working with data collections and databases.</td>
                    </tr>
                    <tr>
                        <td><strong>Migrations</strong></td>
                        <td>EF Core feature to update database schema as your model changes.</td>
                    </tr>
                    <tr>
                        <td><strong>Relationships</strong></td>
                        <td>Define data relationships (1:1, 1:N, N:N) between entities.</td>
                    </tr>
                    <tr>
                        <td><strong>Loading Strategies</strong></td>
                        <td>Eager, Lazy, and Explicit loading determine when data is fetched from DB.</td>
                    </tr>
                    <tr>
                        <td><strong>Repository Pattern</strong></td>
                        <td>Abstraction layer for database operations to promote separation of concerns.</td>
                    </tr>
                    <tr>
                        <td><strong>Dapper</strong></td>
                        <td>Lightweight micro-ORM for faster database access with minimal overhead.</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>🔴 <strong>6. Advanced .NET Core Concepts</strong></h2>
            <table>
                <thead>
                    <tr>
                        <th>Concept</th>
                        <th>Summary</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>SOLID Principles</strong></td>
                        <td>5 design principles for maintainable, scalable code.</td>
                    </tr>
                    <tr>
                        <td><strong>Clean Architecture</strong></td>
                        <td>Organizes applications into layers (Domain, Application, Infrastructure, UI).</td>
                    </tr>
                    <tr>
                        <td><strong>CQRS Pattern</strong></td>
                        <td>Separates read and write operations to optimize performance and scalability.</td>
                    </tr>
                    <tr>
                        <td><strong>Middleware Customization</strong></td>
                        <td>Create your own middleware to handle custom cross-cutting concerns.</td>
                    </tr>
                    <tr>
                        <td><strong>Asynchronous Programming</strong></td>
                        <td>Improves scalability using <code>async</code> / <code>await</code> and Tasks for non-blocking code.</td>
                    </tr>
                    <tr>
                        <td><strong>Background Services</strong></td>
                        <td>Run background tasks using <code>IHostedService</code> or <code>BackgroundService</code>.</td>
                    </tr>
                    <tr>
                        <td><strong>Configuration Providers</strong></td>
                        <td>Load settings from JSON, environment, or secrets storage.</td>
                    </tr>
                    <tr>
                        <td><strong>Logging Providers</strong></td>
                        <td>Integrate external loggers like Serilog or NLog.</td>
                    </tr>
                    <tr>
                        <td><strong>Docker &amp; Containers</strong></td>
                        <td>Package and deploy .NET Core apps in isolated environments.</td>
                    </tr>
                    <tr>
                        <td><strong>CI/CD</strong></td>
                        <td>Automate builds, testing, and deployments (e.g., GitHub Actions, Azure DevOps).</td>
                    </tr>
                    <tr>
                        <td><strong>Caching</strong></td>
                        <td>Improves performance using in-memory or distributed caches (Redis, SQL Server).</td>
                    </tr>
                    <tr>
                        <td><strong>Unit Testing</strong></td>
                        <td>Validate individual components with xUnit, NUnit, or MSTest.</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>⚫ <strong>7. Cloud &amp; Microservices</strong></h2>
            <table>
                <thead>
                    <tr>
                        <th>Concept</th>
                        <th>Summary</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Microservices</strong></td>
                        <td>Break large systems into smaller, independently deployable services.</td>
                    </tr>
                    <tr>
                        <td><strong>API Gateway</strong></td>
                        <td>Central entry point for managing multiple microservices (Ocelot, YARP).</td>
                    </tr>
                    <tr>
                        <td><strong>Service Communication</strong></td>
                        <td>REST, gRPC, or messaging systems (RabbitMQ, Azure Service Bus).</td>
                    </tr>
                    <tr>
                        <td><strong>Service Discovery</strong></td>
                        <td>Dynamically locate services (Consul, Eureka).</td>
                    </tr>
                    <tr>
                        <td><strong>Distributed Tracing</strong></td>
                        <td>Track requests across multiple microservices (Jaeger, OpenTelemetry).</td>
                    </tr>
                    <tr>
                        <td><strong>Azure Integration</strong></td>
                        <td>Deploy apps to Azure (App Service, Functions, Key Vault, Storage).</td>
                    </tr>
                    <tr>
                        <td><strong>AWS Integration</strong></td>
                        <td>Run .NET Core apps on AWS Lambda, ECS, or EC2.</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>⚪ <strong>8. Modern .NET Topics</strong></h2>
            <table>
                <thead>
                    <tr>
                        <th>Concept</th>
                        <th>Summary</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Minimal APIs</strong></td>
                        <td>Lightweight API endpoints introduced in .NET 6+, ideal for small or microservices.</td>
                    </tr>
                    <tr>
                        <td><strong>Blazor</strong></td>
                        <td>Framework for building interactive web UIs using C# instead of JavaScript.</td>
                    </tr>
                    <tr>
                        <td><strong>SignalR</strong></td>
                        <td>Enables real-time communication (e.g., chat apps, dashboards).</td>
                    </tr>
                    <tr>
                        <td><strong>gRPC</strong></td>
                        <td>High-performance communication protocol using Protobuf; faster than REST for internal APIs.</td>
                    </tr>
                    <tr>
                        <td><strong>Worker Services</strong></td>
                        <td>Long-running background processes built on the generic host.</td>
                    </tr>
                    <tr>
                        <td><strong>Localization &amp; Globalization</strong></td>
                        <td>Support for multiple languages and cultures in your app.</td>
                    </tr>
                    <tr>
                        <td><strong>IdentityServer &amp; OAuth</strong></td>
                        <td>Standards-based authentication and authorization solutions.</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>✅ <strong>Summary Overview Table</strong></h2>
            <table>
                <thead>
                    <tr>
                        <th>Level</th>
                        <th>Focus</th>
                        <th>Example Topics</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>🟢 Basic</td>
                        <td>Core runtime &amp; structure</td>
                        <td>CLR, Assemblies, NuGet</td>
                    </tr>
                    <tr>
                        <td>🟡 C# &amp; OOP</td>
                        <td>Programming fundamentals</td>
                        <td>Classes, Inheritance, Polymorphism</td>
                    </tr>
                    <tr>
                        <td>🟠 Intermediate</td>
                        <td>Core architecture</td>
                        <td>Middleware, DI, Logging</td>
                    </tr>
                    <tr>
                        <td>🔵 Web</td>
                        <td>Web &amp; API development</td>
                        <td>MVC, Routing, Razor, Security</td>
                    </tr>
                    <tr>
                        <td>🟣 Data</td>
                        <td>Data access layer</td>
                        <td>EF Core, LINQ, Migrations</td>
                    </tr>
                    <tr>
                        <td>🔴 Advanced</td>
                        <td>Design patterns &amp; performance</td>
                        <td>SOLID, CQRS, Docker, Async</td>
                    </tr>
                    <tr>
                        <td>⚫ Cloud</td>
                        <td>Microservices &amp; cloud</td>
                        <td>gRPC, Azure, API Gateway</td>
                    </tr>
                    <tr>
                        <td>⚪ Modern</td>
                        <td>Latest .NET innovations</td>
                        <td>Minimal APIs, Blazor, SignalR</td>
                    </tr>
                </tbody>
            </table>
            <hr />
        </div>
    </TabPage>
    <TabPage Title="OAuth2">
        <div class="content">
            <h1>🔐 <strong>OAuth 2.0</strong></h1>
            <hr />
            <h2>🚀 <strong>1. Definition</strong></h2>
            <p><strong>OAuth 2.0</strong> (Open Authorization) is a <strong>standard authorization framework</strong> that allows a user or application to <strong>access resources on behalf of another user or system</strong> &mdash; without exposing credentials.</p>
            <p>👉 It uses <strong>tokens</strong> (usually JWTs) instead of passwords.</p>
            <blockquote>
                <p><strong>Example:</strong><br /> &ldquo;Login with Google&rdquo; &mdash; your app never gets the Google password; it gets a <strong>token</strong> that grants limited access to the user&rsquo;s data.</p>
            </blockquote>
            <hr />
            <h2>🧩 <strong>2. Key Entities</strong></h2>
            <table>
                <thead>
                    <tr>
                        <th>Entity</th>
                        <th>Description</th>
                        <th>Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Resource Owner</strong></td>
                        <td>The person or system that owns the data.</td>
                        <td>You (the user)</td>
                    </tr>
                    <tr>
                        <td><strong>Client</strong></td>
                        <td>The app that wants to access data.</td>
                        <td>A web or mobile app</td>
                    </tr>
                    <tr>
                        <td><strong>Resource Server</strong></td>
                        <td>The API hosting protected data.</td>
                        <td><code>api.yourapp.com</code></td>
                    </tr>
                    <tr>
                        <td><strong>Authorization Server</strong></td>
                        <td>Issues tokens after authentication.</td>
                        <td>Google Auth, Azure AD, IdentityServer</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>🧱 <strong>3. Core Token Types</strong></h2>
            <table>
                <thead>
                    <tr>
                        <th>Token</th>
                        <th>Description</th>
                        <th>Lifetime</th>
                        <th>Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Access Token</strong></td>
                        <td>Grants access to resources (often JWT).</td>
                        <td>Short-lived (e.g., 15&ndash;60 mins)</td>
                        <td><code>eyJhbGciOiJI...</code></td>
                    </tr>
                    <tr>
                        <td><strong>Refresh Token</strong></td>
                        <td>Used to get a new access token when it expires.</td>
                        <td>Long-lived (hours&ndash;days)</td>
                        <td><code>9a3f8b2...</code></td>
                    </tr>
                    <tr>
                        <td><strong>ID Token</strong></td>
                        <td>(OpenID Connect) Carries user identity info.</td>
                        <td>Short-lived</td>
                        <td>Contains name, email, etc.</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>🔄 <strong>4. Common OAuth 2.0 Flows</strong></h2>
            <table>
                <thead>
                    <tr>
                        <th>Flow</th>
                        <th>Use Case</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Authorization Code Flow (with PKCE)</strong></td>
                        <td>Web &amp; mobile apps (secure)</td>
                        <td>User logs in via browser &rarr; gets code &rarr; app exchanges for tokens.</td>
                    </tr>
                    <tr>
                        <td><strong>Client Credentials Flow</strong></td>
                        <td>Machine-to-machine (B2B)</td>
                        <td>App authenticates itself &rarr; receives access token.</td>
                    </tr>
                    <tr>
                        <td><strong>Password Grant Flow</strong></td>
                        <td>Legacy or trusted apps</td>
                        <td>App sends username/password &rarr; gets token (not recommended).</td>
                    </tr>
                    <tr>
                        <td><strong>Implicit Flow</strong></td>
                        <td>Browser-only apps (legacy)</td>
                        <td>Tokens sent in redirect URL (less secure, deprecated).</td>
                    </tr>
                    <tr>
                        <td><strong>Refresh Token Flow</strong></td>
                        <td>Session renewal</td>
                        <td>Client exchanges refresh token for new access token.</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>🧾 <strong>5. Token Structure (JWT Example)</strong></h2>
            <p>A <strong>JWT access token</strong> (most common in OAuth 2.0):</p>
<pre><code>Header.Payload.Signature
</code></pre>
            <p><strong>Example Payload:</strong></p>
<pre><code class="language-json">{
  "sub": "user123",
  "name": "John Doe",
  "aud": "https://api.yourapp.com",
  "scope": "read:orders write:orders",
  "iss": "https://login.yourapp.com",
  "exp": 1734030000
}
</code></pre>
            <ul>
                <li>
                    <p><strong>Header</strong> &rarr; Algorithm and token type</p>
                </li>
                <li>
                    <p><strong>Payload</strong> &rarr; Claims (user/app data)</p>
                </li>
                <li>
                    <p><strong>Signature</strong> &rarr; Verifies integrity using secret/private key</p>
                </li>
            </ul>
            <hr />
            <h2>⚙️ <strong>6. OAuth Authorization Concepts</strong></h2>
            <table>
                <thead>
                    <tr>
                        <th>Concept</th>
                        <th>Description</th>
                        <th>Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Roles</strong></td>
                        <td>User/app groups defining access level.</td>
                        <td><code>Admin</code>, <code>User</code>, <code>PartnerApp</code></td>
                    </tr>
                    <tr>
                        <td><strong>Scopes</strong></td>
                        <td>Define what actions are allowed.</td>
                        <td><code>read:orders</code>, <code>write:orders</code></td>
                    </tr>
                    <tr>
                        <td><strong>Claims</strong></td>
                        <td>Info about the user/app encoded in token.</td>
                        <td><code>email</code>, <code>department</code>, <code>role</code></td>
                    </tr>
                    <tr>
                        <td><strong>Policies</strong></td>
                        <td>Custom logic combining roles/claims.</td>
                        <td>&ldquo;Sales Manager can read orders.&rdquo;</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>🛡️ <strong>7. Protecting Resources (APIs)</strong></h2>
            <p>To <strong>secure APIs</strong> in .NET (ASP.NET Core), you must:</p>
            <hr />
            <h3>🔸 <strong>Step 1: Require Authentication</strong></h3>
            <p>In your <code>Program.cs</code>:</p>
<pre><code class="language-csharp">services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =&gt;
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = "https://login.yourapp.com",
            ValidAudience = "https://api.yourapp.com",
            IssuerSigningKey = new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes("YourSuperSecretKey"))
        };
    });
</code></pre>
            <hr />
            <h3>🔸 <strong>Step 2: Require Authorization on Endpoints</strong></h3>
<pre><code class="language-csharp">[Authorize]
[HttpGet("orders")]
public IActionResult GetOrders()
{
    return Ok("Only authenticated users can access this.");
}
</code></pre>
            <hr />
            <h3>🔸 <strong>Step 3: Use Scopes or Roles for Fine-Grained Access</strong></h3>
            <h4>✅ Role-based</h4>
<pre><code class="language-csharp">[Authorize(Roles = "Admin")]
</code></pre>
            <h4>✅ Scope-based (Policy)</h4>
<pre><code class="language-csharp">services.AddAuthorization(options =&gt;
{
    options.AddPolicy("Orders.Read", policy =&gt;
        policy.RequireClaim("scope", "read:orders"));
});
</code></pre>
            <p>Usage:</p>
<pre><code class="language-csharp">[Authorize(Policy = "Orders.Read")]
public IActionResult GetOrders() =&gt; Ok("Order data");
</code></pre>
            <hr />
            <h3>🔸 <strong>Step 4: Secure Communication</strong></h3>
            <p>Always:</p>
            <ul>
                <li>
                    <p>Use <strong>HTTPS</strong> (to prevent token sniffing)</p>
                </li>
                <li>
                    <p>Use <strong>short-lived access tokens</strong></p>
                </li>
                <li>
                    <p>Use <strong>refresh tokens</strong> securely (encrypted, HttpOnly cookies)</p>
                </li>
                <li>
                    <p>Rotate <strong>client secrets or certificates</strong></p>
                </li>
                <li>
                    <p>Validate <strong>audience, issuer, and signature</strong></p>
                </li>
            </ul>
            <hr />
            <h2>🧰 <strong>8. How Resource Server Validates Tokens</strong></h2>
            <p>When an API receives a request with:</p>
<pre><code>Authorization: Bearer &lt;access_token&gt;
</code></pre>
            <p>It performs these checks:</p>
            <ol>
                <li>
                    <p>✅ <strong>Signature Validation</strong> &mdash; verify token wasn&rsquo;t modified</p>
                </li>
                <li>
                    <p>✅ <strong>Issuer Check</strong> &mdash; ensure token was issued by a trusted server</p>
                </li>
                <li>
                    <p>✅ <strong>Audience Check</strong> &mdash; confirm the token was meant for this API</p>
                </li>
                <li>
                    <p>✅ <strong>Expiration Check</strong> &mdash; ensure token hasn&rsquo;t expired</p>
                </li>
                <li>
                    <p>✅ <strong>Claims Check</strong> &mdash; ensure user/app has required role/scope</p>
                </li>
            </ol>
            <p>If all pass &rarr; <strong>access granted</strong>.<br /> Otherwise &rarr; <strong>401 Unauthorized</strong> or <strong>403 Forbidden</strong>.</p>
            <hr />
            <h2>🔒 <strong>9. Best Practices to Protect Resources</strong></h2>
            <table>
                <thead>
                    <tr>
                        <th>Practice</th>
                        <th>Why It&rsquo;s Important</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>🔐 Use HTTPS</td>
                        <td>Prevents token theft</td>
                    </tr>
                    <tr>
                        <td>⏰ Use short-lived tokens</td>
                        <td>Limits exposure window</td>
                    </tr>
                    <tr>
                        <td>♻️ Rotate secrets/keys</td>
                        <td>Prevents long-term compromise</td>
                    </tr>
                    <tr>
                        <td>🧱 Validate audience &amp; issuer</td>
                        <td>Avoid accepting tokens from untrusted sources</td>
                    </tr>
                    <tr>
                        <td>🕵️&zwj;♂️ Limit scopes</td>
                        <td>Least-privilege principle</td>
                    </tr>
                    <tr>
                        <td>🧾 Log and monitor</td>
                        <td>Detect suspicious access</td>
                    </tr>
                    <tr>
                        <td>🧍&zwj;♂️ Use refresh tokens securely</td>
                        <td>Store in HttpOnly cookies</td>
                    </tr>
                    <tr>
                        <td>🧩 Use rate limiting</td>
                        <td>Prevent brute-force or DoS attacks</td>
                    </tr>
                    <tr>
                        <td>🧱 Use API gateway</td>
                        <td>Centralize token validation and logging</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>🌍 <strong>10. Visual Summary (Flow)</strong></h2>
            <p><strong>User/Client App &rarr; Authorization Server &rarr; Resource Server</strong></p>
            <p>1️⃣ User authenticates &rarr; gets <strong>access token</strong><br /> 2️⃣ Client sends <code>Authorization: Bearer &lt;token&gt;</code> to API<br /> 3️⃣ API validates token (signature, issuer, audience, expiry)<br /> 4️⃣ If valid &rarr; access granted to protected resource<br /> 5️⃣ If expired &rarr; client uses <strong>refresh token</strong> to get a new one</p>
            <hr />
            <h2>✅ <strong>11. Quick Summary Table</strong></h2>
            <table>
                <thead>
                    <tr>
                        <th>Concept</th>
                        <th>Summary</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>OAuth 2.0</strong></td>
                        <td>Authorization framework for delegated access</td>
                    </tr>
                    <tr>
                        <td><strong>JWT</strong></td>
                        <td>Token format containing identity and claims</td>
                    </tr>
                    <tr>
                        <td><strong>Access Token</strong></td>
                        <td>Short-lived key for API access</td>
                    </tr>
                    <tr>
                        <td><strong>Refresh Token</strong></td>
                        <td>Used to renew access tokens</td>
                    </tr>
                    <tr>
                        <td><strong>Scopes</strong></td>
                        <td>Define allowed operations</td>
                    </tr>
                    <tr>
                        <td><strong>Roles</strong></td>
                        <td>Define user/app hierarchy</td>
                    </tr>
                    <tr>
                        <td><strong>Resource Server</strong></td>
                        <td>API that enforces authorization</td>
                    </tr>
                    <tr>
                        <td><strong>Authorization Server</strong></td>
                        <td>Issues tokens after authentication</td>
                    </tr>
                    <tr>
                        <td><strong>Best Protection</strong></td>
                        <td>Validate token, use HTTPS, short token life, minimal scopes</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>🧠 <strong>Key Takeaways</strong></h2>
            <ul>
                <li>
                    <p>OAuth 2.0 handles <strong>authorization</strong>, not authentication (OIDC adds identity).</p>
                </li>
                <li>
                    <p>Always validate JWTs in your resource server.</p>
                </li>
                <li>
                    <p>Protect APIs using <code>[Authorize]</code>, roles, scopes, or policies.</p>
                </li>
                <li>
                    <p>Never trust data just because it comes from your frontend &mdash; always revalidate on the backend.</p>
                </li>
                <li>
                    <p>Apply the <strong>Principle of Least Privilege</strong>: give tokens only the access they truly need.</p>
                </li>
            </ul>
            <hr />
            <h1>🔐 <strong>JWT (JSON Web Token)</strong></h1>
            <hr />
            <h2>🚀 <strong>1. What is JWT?</strong></h2>
            <p><strong>JWT (JSON Web Token)</strong> is a <strong>compact, URL-safe token format</strong> used to securely transmit information between two parties &mdash; typically for <strong>authentication</strong> and <strong>authorization</strong>.</p>
            <blockquote>
                <p>Think of a JWT as a <strong>digital passport</strong>: it proves <em>who you are</em> and <em>what you&rsquo;re allowed to do</em> without needing to log in repeatedly.</p>
            </blockquote>
            <hr />
            <h2>🧩 <strong>2. JWT Structure</strong></h2>
            <p>A JWT is made up of <strong>three parts</strong>, separated by dots <code>.</code>:</p>
<pre><code>Header.Payload.Signature
</code></pre>
            <p>Example:</p>
<pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6Ikpv
aG4gRG9lIiwicm9sZSI6IkFkbWluIn0.
TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
</code></pre>
            <hr />
            <h3>🔹 <strong>Header</strong></h3>
            <p>Defines <strong>metadata</strong> about the token &mdash; mainly the algorithm and type.</p>
<pre><code class="language-json">{
  "alg": "HS256",
  "typ": "JWT"
}
</code></pre>
            <blockquote>
                <ul>
                    <li>
                        <p><code>alg</code> &rarr; Signing algorithm (e.g., HS256, RS256)</p>
                    </li>
                    <li>
                        <p><code>typ</code> &rarr; Token type (usually &ldquo;JWT&rdquo;)</p>
                    </li>
                </ul>
            </blockquote>
            <hr />
            <h3>🔹 <strong>Payload</strong></h3>
            <p>Contains the <strong>claims</strong> &mdash; information about the user or app.</p>
<pre><code class="language-json">{
  "sub": "user123",
  "name": "John Doe",
  "email": "john@example.com",
  "role": "Admin",
  "iss": "https://auth.myapp.com",
  "aud": "https://api.myapp.com",
  "exp": 1734030000
}
</code></pre>
            <p>Common claim types:</p>
            <table>
                <thead>
                    <tr>
                        <th>Claim</th>
                        <th>Meaning</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>sub</strong></td>
                        <td>Subject (user ID)</td>
                    </tr>
                    <tr>
                        <td><strong>name</strong></td>
                        <td>User name</td>
                    </tr>
                    <tr>
                        <td><strong>email</strong></td>
                        <td>User&rsquo;s email</td>
                    </tr>
                    <tr>
                        <td><strong>role</strong></td>
                        <td>User&rsquo;s role</td>
                    </tr>
                    <tr>
                        <td><strong>iss</strong></td>
                        <td>Issuer (who created the token)</td>
                    </tr>
                    <tr>
                        <td><strong>aud</strong></td>
                        <td>Audience (who can use the token)</td>
                    </tr>
                    <tr>
                        <td><strong>exp</strong></td>
                        <td>Expiration time</td>
                    </tr>
                    <tr>
                        <td><strong>iat</strong></td>
                        <td>Issued at</td>
                    </tr>
                    <tr>
                        <td><strong>nbf</strong></td>
                        <td>Not before (valid from)</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h3>🔹 <strong>Signature</strong></h3>
            <p>Used to verify that the token hasn&rsquo;t been altered.</p>
            <p>Example process:</p>
<pre><code>HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret_key
)
</code></pre>
            <p>The <strong>signature</strong> ensures <strong>integrity</strong> &mdash; if someone changes the payload, the signature becomes invalid.</p>
            <hr />
            <h2>🧱 <strong>3. Types of JWT</strong></h2>
            <table>
                <thead>
                    <tr>
                        <th>Type</th>
                        <th>Description</th>
                        <th>Used For</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Access Token</strong></td>
                        <td>Grants access to protected APIs.</td>
                        <td>Authorization</td>
                    </tr>
                    <tr>
                        <td><strong>ID Token</strong></td>
                        <td>Contains user identity info (used in OpenID Connect).</td>
                        <td>Authentication</td>
                    </tr>
                    <tr>
                        <td><strong>Refresh Token</strong></td>
                        <td>Used to get new access tokens.</td>
                        <td>Session continuation</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>🔄 <strong>4. JWT Lifecycle</strong></h2>
            <p>1️⃣ <strong>User logs in</strong> &rarr; authentication server verifies credentials.<br /> 2️⃣ <strong>Server issues JWT</strong> &rarr; includes claims, signs with a key.<br /> 3️⃣ <strong>Client stores token</strong> &rarr; usually in browser storage or cookie.<br /> 4️⃣ <strong>Client sends token</strong> &rarr; in every request header:</p>
<pre><code>Authorization: Bearer &lt;jwt&gt;
</code></pre>
            <p>5️⃣ <strong>API validates JWT</strong> &rarr; checks signature, expiration, issuer, audience.<br /> 6️⃣ <strong>Access granted</strong> &rarr; if valid; else <code>401 Unauthorized</code>.</p>
            <hr />
            <h2>⚙️ <strong>5. JWT Validation Steps</strong></h2>
            <p>When an API receives a JWT:</p>
            <p>✅ <strong>1. Signature validation</strong> &mdash; ensures it&rsquo;s not tampered with.<br /> ✅ <strong>2. Issuer (<code>iss</code>) check</strong> &mdash; must match your trusted auth server.<br /> ✅ <strong>3. Audience (<code>aud</code>) check</strong> &mdash; token must be meant for this API.<br /> ✅ <strong>4. Expiration (<code>exp</code>) check</strong> &mdash; must not be expired.<br /> ✅ <strong>5. Claims check</strong> &mdash; roles, scopes, or permissions.</p>
            <p>If any check fails &rarr; reject request.</p>
            <hr />
            <h2>🛠 <strong>6. JWT in ASP.NET Core</strong></h2>
            <h3>🔸 <strong>Setup in Program.cs</strong></h3>
<pre><code class="language-csharp">services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =&gt;
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = "https://auth.myapp.com",
            ValidAudience = "https://api.myapp.com",
            IssuerSigningKey = new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes("SuperSecretKey123"))
        };
    });
</code></pre>
            <h3>🔸 <strong>Secure a Controller</strong></h3>
<pre><code class="language-csharp">[Authorize]
[HttpGet("orders")]
public IActionResult GetOrders() =&gt; Ok("Authorized access");
</code></pre>
            <hr />
            <h2>🔒 <strong>7. Where to Store JWT (Client-Side)</strong></h2>
            <table>
                <thead>
                    <tr>
                        <th>Storage Method</th>
                        <th>Pros</th>
                        <th>Cons</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>HttpOnly Cookie</strong></td>
                        <td>Secure (protected from JS access), auto-sent</td>
                        <td>CSRF risk if not mitigated</td>
                    </tr>
                    <tr>
                        <td><strong>LocalStorage / SessionStorage</strong></td>
                        <td>Easy to use</td>
                        <td>Vulnerable to XSS attacks</td>
                    </tr>
                    <tr>
                        <td><strong>In-memory (state)</strong></td>
                        <td>Safer from XSS</td>
                        <td>Lost on page reload (needs refresh token)</td>
                    </tr>
                </tbody>
            </table>
            <p>✅ <strong>Best practice:</strong> Use <strong>HttpOnly + Secure cookies</strong> and implement <strong>CSRF protection</strong>.</p>
            <hr />
            <h2>⚖️ <strong>8. Advantages of JWT</strong></h2>
            <p>✅ Stateless &mdash; server doesn&rsquo;t need to store sessions<br /> ✅ Compact &mdash; small and fast to transmit<br /> ✅ Portable &mdash; works across systems (cross-domain)<br /> ✅ Self-contained &mdash; includes all claims needed for validation</p>
            <hr />
            <h2>⚠️ <strong>9. Disadvantages / Security Risks</strong></h2>
            <p>❌ Hard to revoke &mdash; can&rsquo;t invalidate tokens easily before expiration<br /> ❌ Must use HTTPS &mdash; tokens are bearer-based (anyone with token = access)<br /> ❌ Sensitive info should <strong>never</strong> be in the payload (even if base64 encoded)<br /> ❌ Key leakage = total compromise</p>
            <hr />
            <h2>🧱 <strong>10. JWT vs Session Tokens</strong></h2>
            <table>
                <thead>
                    <tr>
                        <th>Feature</th>
                        <th><strong>JWT</strong></th>
                        <th><strong>Traditional Session</strong></th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Storage</strong></td>
                        <td>Client-side</td>
                        <td>Server-side</td>
                    </tr>
                    <tr>
                        <td><strong>State</strong></td>
                        <td>Stateless</td>
                        <td>Stateful</td>
                    </tr>
                    <tr>
                        <td><strong>Scaling</strong></td>
                        <td>Easy (no shared session)</td>
                        <td>Hard (requires shared cache)</td>
                    </tr>
                    <tr>
                        <td><strong>Revocation</strong></td>
                        <td>Difficult</td>
                        <td>Easy (clear session)</td>
                    </tr>
                    <tr>
                        <td><strong>Performance</strong></td>
                        <td>High</td>
                        <td>Moderate</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>🧰 <strong>11. JWT Use Cases</strong></h2>
            <ul>
                <li>
                    <p>RESTful APIs</p>
                </li>
                <li>
                    <p>Single Page Applications (SPA)</p>
                </li>
                <li>
                    <p>Microservices authentication</p>
                </li>
                <li>
                    <p>Mobile app authentication</p>
                </li>
                <li>
                    <p>B2B and B2C token exchange</p>
                </li>
            </ul>
            <hr />
            <h2>🔐 <strong>12. Protecting Resources with JWT</strong></h2>
            <table>
                <thead>
                    <tr>
                        <th>Step</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>1. Use HTTPS</strong></td>
                        <td>Prevent token interception</td>
                    </tr>
                    <tr>
                        <td><strong>2. Validate Signature</strong></td>
                        <td>Ensure token integrity</td>
                    </tr>
                    <tr>
                        <td><strong>3. Validate Issuer &amp; Audience</strong></td>
                        <td>Accept tokens only from trusted issuers</td>
                    </tr>
                    <tr>
                        <td><strong>4. Enforce Expiry</strong></td>
                        <td>Reject expired tokens</td>
                    </tr>
                    <tr>
                        <td><strong>5. Use Role/Scope Authorization</strong></td>
                        <td>Control access to resources</td>
                    </tr>
                    <tr>
                        <td><strong>6. Rotate Signing Keys</strong></td>
                        <td>Mitigate long-term risk</td>
                    </tr>
                    <tr>
                        <td><strong>7. Limit Token Lifetime</strong></td>
                        <td>Reduce exposure window</td>
                    </tr>
                    <tr>
                        <td><strong>8. Avoid Sensitive Claims</strong></td>
                        <td>JWT is only base64-encoded, not encrypted</td>
                    </tr>
                    <tr>
                        <td><strong>9. Implement Refresh Tokens Securely</strong></td>
                        <td>For long sessions</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>🧠 <strong>13. Quick Summary Table</strong></h2>
            <table>
                <thead>
                    <tr>
                        <th>Concept</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>JWT</strong></td>
                        <td>JSON-based token format for authentication/authorization</td>
                    </tr>
                    <tr>
                        <td><strong>Parts</strong></td>
                        <td>Header, Payload, Signature</td>
                    </tr>
                    <tr>
                        <td><strong>Common Claims</strong></td>
                        <td><code>sub</code>, <code>iss</code>, <code>aud</code>, <code>exp</code>, <code>role</code>, <code>scope</code></td>
                    </tr>
                    <tr>
                        <td><strong>Validation</strong></td>
                        <td>Check signature, issuer, audience, expiry</td>
                    </tr>
                    <tr>
                        <td><strong>Security</strong></td>
                        <td>Use HTTPS, short expiry, and key rotation</td>
                    </tr>
                    <tr>
                        <td><strong>Storage</strong></td>
                        <td>Prefer HttpOnly secure cookies</td>
                    </tr>
                    <tr>
                        <td><strong>Best For</strong></td>
                        <td>Stateless authentication in APIs and microservices</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>🧩 <strong>14. Example JWT Flow Summary</strong></h2>
            <p>1️⃣ User authenticates &rarr; server issues JWT<br /> 2️⃣ Client stores JWT<br /> 3️⃣ Client sends <code>Authorization: Bearer &lt;jwt&gt;</code> to API<br /> 4️⃣ API validates token<br /> 5️⃣ API grants access based on roles/scopes</p>
            <hr />
            <h2>🧭 <strong>15. Mnemonic to Remember JWT Flow</strong></h2>
            <p><strong>I.S.S.U.E.</strong></p>
            <table>
                <thead>
                    <tr>
                        <th>Letter</th>
                        <th>Meaning</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>I</strong></td>
                        <td><strong>I</strong>ssue token after login</td>
                    </tr>
                    <tr>
                        <td><strong>S</strong></td>
                        <td><strong>S</strong>tore token securely</td>
                    </tr>
                    <tr>
                        <td><strong>S</strong></td>
                        <td><strong>S</strong>end token in Authorization header</td>
                    </tr>
                    <tr>
                        <td><strong>U</strong></td>
                        <td><strong>U</strong>se middleware to validate token</td>
                    </tr>
                    <tr>
                        <td><strong>E</strong></td>
                        <td><strong>E</strong>nforce expiry and scopes</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <p>✅ <strong>Final Takeaway:</strong></p>
            <blockquote>
                <p>JWT = <strong>Compact, Signed, Self-contained token</strong><br /> Used for <strong>stateless authentication</strong> and <strong>API authorization</strong>.<br /> Always <strong>validate carefully</strong>, <strong>store securely</strong>, and <strong>use HTTPS</strong>.</p>
            </blockquote>
            <hr />
        </div>
    </TabPage>
    <TabPage Title="Exception Handling">
        <div class="content">
            <p>👍 Here&rsquo;s a <strong>visual diagram and summary explanation</strong> that shows how <strong>exception handling works at different levels</strong> in an <strong>ASP.NET Core pipeline</strong>, including:</p>
            <ul>
                <li>
                    <p><code>try-catch</code> in controllers</p>
                </li>
                <li>
                    <p><strong>Global Exception Filters</strong></p>
                </li>
                <li>
                    <p><strong>Middleware</strong></p>
                </li>
            </ul>
            <hr />
            <h2>🧩 <strong>ASP.NET Core Request Pipeline &mdash; Exception Handling Layers</strong></h2>
<pre><code> ┌────────────────────────────────────────────────────────────┐
 │                   Incoming HTTP Request                    │
 └────────────────────────────────────────────────────────────┘
                 │
                 ▼
 ┌────────────────────────────────────────────────────────────┐
 │        Exception Handling Middleware (Global Layer)        │
 │  &bull; Catches ANY exception in the entire pipeline            │
 │  &bull; Logs and returns standard JSON response (500 error)     │
 └────────────────────────────────────────────────────────────┘
                 │
                 ▼
 ┌────────────────────────────────────────────────────────────┐
 │        Other Middlewares (Routing, Auth, etc.)             │
 └────────────────────────────────────────────────────────────┘
                 │
                 ▼
 ┌────────────────────────────────────────────────────────────┐
 │                MVC / API Controller Layer                  │
 │                                                            │
 │   ┌────────────────────────────────────────────────────┐   │
 │   │         Global Exception Filter (Controller-Level)  │   │
 │   │  &bull; Catches exceptions thrown inside controllers     │   │
 │   │  &bull; Converts them into consistent API responses      │   │
 │   └────────────────────────────────────────────────────┘   │
 │                                                            │
 │   ┌────────────────────────────────────────────────────┐   │
 │   │          Action Method (Business Logic)            │   │
 │   │  &bull; Local try-catch handles known issues             │   │
 │   │  &bull; Logs and returns user-friendly error message     │   │
 │   └────────────────────────────────────────────────────┘   │
 │                                                            │
 └────────────────────────────────────────────────────────────┘
                 │
                 ▼
 ┌────────────────────────────────────────────────────────────┐
 │               Outgoing HTTP Response (JSON)                │
 │   &bull; Successful response OR standardized error message      │
 └────────────────────────────────────────────────────────────┘
</code></pre>
            <hr />
            <h2>🧠 <strong>Explanation by Layer</strong></h2>
            <table>
                <thead>
                    <tr>
                        <th>Layer</th>
                        <th>Handles</th>
                        <th>Scope</th>
                        <th>Typical Use</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>🧱 <strong>Middleware</strong></td>
                        <td>Any exception from <em>anywhere</em> in pipeline</td>
                        <td>Entire application</td>
                        <td>Catch-all for unhandled errors, logs, consistent JSON</td>
                    </tr>
                    <tr>
                        <td>🧩 <strong>Global Exception Filter (<code>IExceptionFilter</code>)</strong></td>
                        <td>Exceptions from controllers/actions</td>
                        <td>MVC layer only</td>
                        <td>Converts exceptions to consistent API responses</td>
                    </tr>
                    <tr>
                        <td>🎯 <strong>try-catch (Controller)</strong></td>
                        <td>Expected exceptions</td>
                        <td>Single action or service method</td>
                        <td>For fine-grained control (validation, business rules)</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>🔍 <strong>Flow Example</strong></h2>
            <p><strong>Scenario:</strong></p>
            <ul>
                <li>
                    <p>You have a controller that calls a service.</p>
                </li>
                <li>
                    <p>The service throws a <code>SqlException</code>.</p>
                </li>
            </ul>
            <h3>Flow:</h3>
            <p>1️⃣ Exception is thrown in <code>UserService</code>.<br /> 2️⃣ Controller has no <code>try-catch</code> &rarr; exception bubbles up.<br /> 3️⃣ Global <strong>Exception Filter</strong> catches it &rarr; returns <code>500</code> JSON error.<br /> 4️⃣ If the filter didn&rsquo;t exist, the <strong>Middleware</strong> would catch it next.</p>
            <p>✅ <strong>Result:</strong><br /> The user still gets a clean, structured API error response &mdash; <em>no crash, no raw stack trace.</em></p>
            <hr />
            <h2>🧾 <strong>Example Output (from Filter or Middleware)</strong></h2>
<pre><code class="language-json">{
  "message": "An unexpected error occurred.",
  "details": "Database connection failed.",
  "traceId": "00-84fa4e4e123abc45",
  "timestamp": "2025-10-12T19:20:44Z"
}
</code></pre>
            <hr />
            <h2>⚖️ <strong>Summary &mdash; Which to Use When</strong></h2>
            <table>
                <thead>
                    <tr>
                        <th>Layer</th>
                        <th>Pros</th>
                        <th>Cons</th>
                        <th>Recommended For</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>try-catch (Controller)</strong></td>
                        <td>Precise, per-action control</td>
                        <td>Repetitive, scattered</td>
                        <td>Known or recoverable exceptions</td>
                    </tr>
                    <tr>
                        <td><strong>Global Exception Filter</strong></td>
                        <td>Centralized, consistent response</td>
                        <td>Controller-specific only</td>
                        <td>API-level exception handling</td>
                    </tr>
                    <tr>
                        <td><strong>Middleware</strong></td>
                        <td>Works for everything (auth, filters, etc.)</td>
                        <td>No access to MVC context</td>
                        <td>Application-wide catch-all</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>✅ <strong>Best Practice Combo</strong></h2>
            <p>Use <strong>all three in layers</strong>:</p>
            <ul>
                <li>
                    <p>🔸 <strong><code>try-catch</code></strong> &rarr; handle <em>expected</em> exceptions (validation, business logic).</p>
                </li>
                <li>
                    <p>🔸 <strong><code>IExceptionFilter</code></strong> &rarr; handle <em>controller-level</em> exceptions and format API errors.</p>
                </li>
                <li>
                    <p>🔸 <strong>Middleware</strong> &rarr; global <em>fallback safety net</em> for any unhandled exceptions.</p>
                </li>
            </ul>
            <hr />
        </div>
    </TabPage>
    <TabPage Title="Design Pattern">
        <div class="content">
            <h1>🧱 <strong>1. What Are Design Patterns?</strong></h1>
            <blockquote>
                <p><strong>Design Patterns</strong> are <strong>proven solutions</strong> to <strong>common software design problems</strong>.<br /> They provide templates on <strong>how to structure your code</strong> for flexibility, scalability, and maintainability.</p>
            </blockquote>
            <p>They are <strong>not code</strong>, but <strong>guidelines</strong> or <strong>blueprints</strong>.</p>
            <hr />
            <h1>⚙️ <strong>2. Types of Design Patterns</strong></h1>
            <table>
                <thead>
                    <tr>
                        <th>Category</th>
                        <th>Description</th>
                        <th>Example Patterns</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Creational</strong></td>
                        <td>How objects are created and instantiated</td>
                        <td>Singleton, Factory, Abstract Factory, Builder, Prototype</td>
                    </tr>
                    <tr>
                        <td><strong>Structural</strong></td>
                        <td>How classes and objects are composed</td>
                        <td>Adapter, Decorator, Facade, Composite, Proxy</td>
                    </tr>
                    <tr>
                        <td><strong>Behavioral</strong></td>
                        <td>How objects communicate and interact</td>
                        <td>Strategy, Observer, Command, Mediator, State, Chain of Responsibility</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>🧩 <strong>3. Creational Patterns</strong></h2>
            <hr />
            <h3>🔸 <strong>3.1 Singleton Pattern</strong></h3>
            <p>Ensures <strong>only one instance</strong> of a class exists throughout the application.</p>
            <p>✅ <strong>Use when:</strong></p>
            <ul>
                <li>
                    <p>You need a single shared resource (like a logger, configuration, or cache manager).</p>
                </li>
            </ul>
<pre><code class="language-csharp">public sealed class Logger
{
    private static readonly Logger _instance = new Logger();

    // Private constructor prevents external instantiation
    private Logger() { }

    public static Logger Instance =&gt; _instance;

    public void Log(string message)
    {
        Console.WriteLine($"[LOG]: {message}");
    }
}
</code></pre>
            <p><strong>Usage:</strong></p>
<pre><code class="language-csharp">Logger.Instance.Log("Application started.");
</code></pre>
            <p>🧠 <em>Tip:</em> Thread-safe and simple in .NET using <code>static</code> initialization.</p>
            <hr />
            <h3>🔸 <strong>3.2 Factory Method Pattern</strong></h3>
            <p>Provides an <strong>interface for creating objects</strong> but lets subclasses decide which class to instantiate.</p>
            <p>✅ <strong>Use when:</strong></p>
            <ul>
                <li>
                    <p>You need to create objects without exposing the creation logic.</p>
                </li>
                <li>
                    <p>The exact type to create depends on input or configuration.</p>
                </li>
            </ul>
<pre><code class="language-csharp">public abstract class CreditCardFactory
{
    public abstract CreditCard CreateCard();
}

public class PlatinumFactory : CreditCardFactory
{
    public override CreditCard CreateCard() =&gt; new PlatinumCard();
}

public class GoldFactory : CreditCardFactory
{
    public override CreditCard CreateCard() =&gt; new GoldCard();
}
</code></pre>
            <p><strong>Usage:</strong></p>
<pre><code class="language-csharp">CreditCardFactory factory = new GoldFactory();
var card = factory.CreateCard();
Console.WriteLine(card.GetCardType()); // "Gold Card"
</code></pre>
            <hr />
            <h3>🔸 <strong>3.3 Abstract Factory Pattern</strong></h3>
            <p>Creates <strong>families of related objects</strong> without specifying concrete classes.</p>
            <p>✅ <strong>Use when:</strong></p>
            <ul>
                <li>
                    <p>You have multiple related products (like UI themes or database providers).</p>
                </li>
            </ul>
<pre><code class="language-csharp">public interface IUIFactory
{
    IButton CreateButton();
    ITextbox CreateTextbox();
}

public class DarkUIFactory : IUIFactory
{
    public IButton CreateButton() =&gt; new DarkButton();
    public ITextbox CreateTextbox() =&gt; new DarkTextbox();
}
</code></pre>
            <p><strong>Usage:</strong></p>
<pre><code class="language-csharp">IUIFactory factory = new DarkUIFactory();
var button = factory.CreateButton();
button.Render();
</code></pre>
            <hr />
            <h3>🔸 <strong>3.4 Builder Pattern</strong></h3>
            <p>Separates object construction from its representation (used for complex objects).</p>
            <p>✅ <strong>Use when:</strong></p>
            <ul>
                <li>
                    <p>You have an object that requires <strong>step-by-step construction</strong> (like a complex DTO or report).</p>
                </li>
            </ul>
<pre><code class="language-csharp">public class Report
{
    public string Title { get; set; }
    public string Body { get; set; }
    public string Footer { get; set; }
}

public class ReportBuilder
{
    private Report _report = new Report();

    public ReportBuilder SetTitle(string title) { _report.Title = title; return this; }
    public ReportBuilder SetBody(string body) { _report.Body = body; return this; }
    public ReportBuilder SetFooter(string footer) { _report.Footer = footer; return this; }

    public Report Build() =&gt; _report;
}
</code></pre>
            <p><strong>Usage:</strong></p>
<pre><code class="language-csharp">var report = new ReportBuilder()
                .SetTitle("Sales Report")
                .SetBody("Report Body")
                .SetFooter("Confidential")
                .Build();
</code></pre>
            <hr />
            <h3>🔸 <strong>3.5 Prototype Pattern</strong></h3>
            <p>Creates a new object by <strong>cloning</strong> an existing one.</p>
            <p>✅ <strong>Use when:</strong></p>
            <ul>
                <li>
                    <p>Creating an object is expensive, and you can reuse an existing instance as a template.</p>
                </li>
            </ul>
<pre><code class="language-csharp">public abstract class Shape
{
    public abstract Shape Clone();
}

public class Circle : Shape
{
    public int Radius { get; set; }
    public override Shape Clone() =&gt; (Shape)this.MemberwiseClone();
}
</code></pre>
            <p><strong>Usage:</strong></p>
<pre><code class="language-csharp">var circle1 = new Circle { Radius = 10 };
var circle2 = (Circle)circle1.Clone();
</code></pre>
            <hr />
            <h2>🧱 <strong>4. Structural Patterns</strong></h2>
            <hr />
            <h3>🔸 <strong>4.1 Adapter Pattern</strong></h3>
            <p>Allows incompatible interfaces to work together.</p>
            <p>✅ <strong>Use when:</strong></p>
            <ul>
                <li>
                    <p>You want to use an existing class but its interface doesn&rsquo;t match your needs.</p>
                </li>
            </ul>
<pre><code class="language-csharp">public interface INewLogger
{
    void LogMessage(string msg);
}

public class OldLogger
{
    public void Log(string msg) =&gt; Console.WriteLine($"Old log: {msg}");
}

public class LoggerAdapter : INewLogger
{
    private readonly OldLogger _oldLogger;
    public LoggerAdapter(OldLogger oldLogger) =&gt; _oldLogger = oldLogger;
    public void LogMessage(string msg) =&gt; _oldLogger.Log(msg);
}
</code></pre>
            <p><strong>Usage:</strong></p>
<pre><code class="language-csharp">INewLogger logger = new LoggerAdapter(new OldLogger());
logger.LogMessage("Adapter pattern in action!");
</code></pre>
            <hr />
            <h3>🔸 <strong>4.2 Decorator Pattern</strong></h3>
            <p>Adds new functionality to an object <strong>without modifying its structure</strong>.</p>
            <p>✅ <strong>Use when:</strong></p>
            <ul>
                <li>
                    <p>You want to dynamically add features to objects.</p>
                </li>
            </ul>
<pre><code class="language-csharp">public interface ICoffee
{
    string GetDescription();
    double GetCost();
}

public class BasicCoffee : ICoffee
{
    public string GetDescription() =&gt; "Basic Coffee";
    public double GetCost() =&gt; 5;
}

public class MilkDecorator : ICoffee
{
    private readonly ICoffee _coffee;
    public MilkDecorator(ICoffee coffee) =&gt; _coffee = coffee;
    public string GetDescription() =&gt; _coffee.GetDescription() + ", Milk";
    public double GetCost() =&gt; _coffee.GetCost() + 1.5;
}
</code></pre>
            <p><strong>Usage:</strong></p>
<pre><code class="language-csharp">ICoffee coffee = new MilkDecorator(new BasicCoffee());
Console.WriteLine($"{coffee.GetDescription()} = ${coffee.GetCost()}");
</code></pre>
            <hr />
            <h3>🔸 <strong>4.3 Facade Pattern</strong></h3>
            <p>Provides a <strong>simplified interface</strong> to a complex subsystem.</p>
            <p>✅ <strong>Use when:</strong></p>
            <ul>
                <li>
                    <p>You want to hide system complexity behind a single class.</p>
                </li>
            </ul>
<pre><code class="language-csharp">public class PaymentFacade
{
    private readonly PaymentService _payment = new();
    private readonly NotificationService _notification = new();

    public void CompleteOrder()
    {
        _payment.ProcessPayment();
        _notification.SendEmail();
    }
}
</code></pre>
            <p><strong>Usage:</strong></p>
<pre><code class="language-csharp">var facade = new PaymentFacade();
facade.CompleteOrder(); // Simplified interface
</code></pre>
            <hr />
            <h3>🔸 <strong>4.4 Proxy Pattern</strong></h3>
            <p>Provides a <strong>placeholder</strong> or <strong>intermediary</strong> for another object.</p>
            <p>✅ <strong>Use when:</strong></p>
            <ul>
                <li>
                    <p>You need to add security, caching, or lazy-loading.</p>
                </li>
            </ul>
<pre><code class="language-csharp">public interface IImage
{
    void Display();
}

public class RealImage : IImage
{
    private readonly string _fileName;
    public RealImage(string fileName) =&gt; _fileName = fileName;
    public void Display() =&gt; Console.WriteLine($"Displaying {_fileName}");
}

public class ProxyImage : IImage
{
    private RealImage _realImage;
    private readonly string _fileName;

    public ProxyImage(string fileName) =&gt; _fileName = fileName;

    public void Display()
    {
        _realImage ??= new RealImage(_fileName);
        _realImage.Display();
    }
}
</code></pre>
            <hr />
            <h2>🧠 <strong>5. Behavioral Patterns</strong></h2>
            <hr />
            <h3>🔸 <strong>5.1 Strategy Pattern</strong></h3>
            <p>Defines a family of algorithms and makes them interchangeable at runtime.</p>
            <p>✅ <strong>Use when:</strong></p>
            <ul>
                <li>
                    <p>You need to switch between multiple algorithms dynamically.</p>
                </li>
            </ul>
<pre><code class="language-csharp">public interface IPaymentStrategy
{
    void Pay(double amount);
}

public class CreditCardPayment : IPaymentStrategy
{
    public void Pay(double amount) =&gt; Console.WriteLine($"Paid {amount} via Credit Card.");
}

public class PayPalPayment : IPaymentStrategy
{
    public void Pay(double amount) =&gt; Console.WriteLine($"Paid {amount} via PayPal.");
}

public class ShoppingCart
{
    private IPaymentStrategy _paymentStrategy;
    public void SetPaymentStrategy(IPaymentStrategy strategy) =&gt; _paymentStrategy = strategy;
    public void Checkout(double amount) =&gt; _paymentStrategy.Pay(amount);
}
</code></pre>
            <p><strong>Usage:</strong></p>
<pre><code class="language-csharp">var cart = new ShoppingCart();
cart.SetPaymentStrategy(new PayPalPayment());
cart.Checkout(100);
</code></pre>
            <hr />
            <h3>🔸 <strong>5.2 Observer Pattern</strong></h3>
            <p>Defines a <strong>one-to-many dependency</strong> &mdash; when one object changes, others are notified.</p>
            <p>✅ <strong>Use when:</strong></p>
            <ul>
                <li>
                    <p>You need to implement event-driven systems or notifications.</p>
                </li>
            </ul>
<pre><code class="language-csharp">public interface IObserver
{
    void Update(string message);
}

public class User : IObserver
{
    public string Name { get; set; }
    public void Update(string message) =&gt; Console.WriteLine($"{Name} received: {message}");
}

public class Channel
{
    private List&lt;IObserver&gt; _observers = new();

    public void Subscribe(IObserver observer) =&gt; _observers.Add(observer);
    public void Notify(string message)
    {
        foreach (var obs in _observers)
            obs.Update(message);
    }
}
</code></pre>
            <p><strong>Usage:</strong></p>
<pre><code class="language-csharp">var channel = new Channel();
channel.Subscribe(new User { Name = "Alice" });
channel.Subscribe(new User { Name = "Bob" });
channel.Notify("New video uploaded!");
</code></pre>
            <hr />
            <h3>🔸 <strong>5.3 Command Pattern</strong></h3>
            <p>Encapsulates a request as an object &mdash; allows undo/redo and queuing actions.</p>
            <p>✅ <strong>Use when:</strong></p>
            <ul>
                <li>
                    <p>You want to log, queue, or undo operations.</p>
                </li>
            </ul>
<pre><code class="language-csharp">public interface ICommand
{
    void Execute();
}

public class Light
{
    public void On() =&gt; Console.WriteLine("Light ON");
    public void Off() =&gt; Console.WriteLine("Light OFF");
}

public class LightOnCommand : ICommand
{
    private Light _light;
    public LightOnCommand(Light light) =&gt; _light = light;
    public void Execute() =&gt; _light.On();
}
</code></pre>
            <p><strong>Usage:</strong></p>
<pre><code class="language-csharp">var light = new Light();
ICommand cmd = new LightOnCommand(light);
cmd.Execute();
</code></pre>
            <hr />
            <h3>🔸 <strong>5.4 Chain of Responsibility Pattern</strong></h3>
            <p>Passes a request along a chain of handlers until one handles it.</p>
            <p>✅ <strong>Use when:</strong></p>
            <ul>
                <li>
                    <p>You need multiple possible handlers for a request (e.g., middleware, logging).</p>
                </li>
            </ul>
<pre><code class="language-csharp">public abstract class Handler
{
    protected Handler Next;
    public void SetNext(Handler next) =&gt; Next = next;
    public abstract void HandleRequest(int value);
}

public class SmallHandler : Handler
{
    public override void HandleRequest(int value)
    {
        if (value &lt; 10)
            Console.WriteLine("Handled by SmallHandler");
        else
            Next?.HandleRequest(value);
    }
}
</code></pre>
            <hr />
            <h1>🧾 <strong>6. Quick Summary Table</strong></h1>
            <table>
                <thead>
                    <tr>
                        <th>Category</th>
                        <th>Pattern</th>
                        <th>Purpose</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Creational</strong></td>
                        <td>Singleton</td>
                        <td>Single global instance</td>
                    </tr>
                    <tr>
                        <td>&nbsp;</td>
                        <td>Factory</td>
                        <td>Centralize object creation</td>
                    </tr>
                    <tr>
                        <td>&nbsp;</td>
                        <td>Abstract Factory</td>
                        <td>Create related objects</td>
                    </tr>
                    <tr>
                        <td>&nbsp;</td>
                        <td>Builder</td>
                        <td>Build complex objects step-by-step</td>
                    </tr>
                    <tr>
                        <td>&nbsp;</td>
                        <td>Prototype</td>
                        <td>Clone existing objects</td>
                    </tr>
                    <tr>
                        <td><strong>Structural</strong></td>
                        <td>Adapter</td>
                        <td>Bridge incompatible interfaces</td>
                    </tr>
                    <tr>
                        <td>&nbsp;</td>
                        <td>Decorator</td>
                        <td>Add features dynamically</td>
                    </tr>
                    <tr>
                        <td>&nbsp;</td>
                        <td>Facade</td>
                        <td>Simplified interface to complex system</td>
                    </tr>
                    <tr>
                        <td>&nbsp;</td>
                        <td>Proxy</td>
                        <td>Control access to object</td>
                    </tr>
                    <tr>
                        <td><strong>Behavioral</strong></td>
                        <td>Strategy</td>
                        <td>Switch algorithms at runtime</td>
                    </tr>
                    <tr>
                        <td>&nbsp;</td>
                        <td>Observer</td>
                        <td>Notify subscribers automatically</td>
                    </tr>
                    <tr>
                        <td>&nbsp;</td>
                        <td>Command</td>
                        <td>Encapsulate actions as objects</td>
                    </tr>
                    <tr>
                        <td>&nbsp;</td>
                        <td>Chain of Responsibility</td>
                        <td>Pass requests through handlers</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <p>✅ <strong>Final Takeaway:</strong></p>
            <blockquote>
                <p>Design Patterns are about <strong>reusable architecture</strong>.<br /> They make systems <strong>flexible, testable, and scalable</strong>.<br /> In .NET, you&rsquo;ll most commonly use <strong>Singleton</strong>, <strong>Factory</strong>, <strong>Strategy</strong>, <strong>Repository</strong>, <strong>Observer</strong>, and <strong>Decorator</strong> patterns.</p>
            </blockquote>
            <hr />
            <h1>🧩 <strong>Design Patterns &mdash; Visual Mind Map</strong></h1>
<pre><code>                           ┌────────────────────────┐
                           │   DESIGN PATTERNS 🧠   │
                           └────────────┬───────────┘
                                        │
     ┌──────────────────────────────────┼──────────────────────────────────┐
     │                                  │                                  │
     ▼                                  ▼                                  ▼
┌───────────────┐              ┌────────────────┐                 ┌─────────────────┐
│ CREATIONAL 🏗️ │              │ STRUCTURAL 🧱 │                 │ BEHAVIORAL ⚙️ │
└───────┬───────┘              └───────┬────────┘                 └───────┬────────┘
        │                                │                                │
        ▼                                ▼                                ▼
┌───────────────┐              ┌────────────────┐               ┌──────────────────┐
│ Singleton 🔁  │              │ Adapter 🔌     │               │ Strategy 🧭      │
│ One instance  │              │ Bridge gaps    │               │ Swap algorithms  │
│ Example: Logger│             │ Example: ILoggerAdapter│       │ Example: PaymentStrategy│
└───────────────┘              └────────────────┘               └──────────────────┘
        │                                │                                │
        ▼                                ▼                                ▼
┌───────────────┐              ┌────────────────┐               ┌──────────────────┐
│ Factory 🏭     │              │ Decorator 🎨   │               │ Observer 🔔      │
│ Create objects │              │ Add features   │               │ Notify subscribers│
│ Example: CardFactory│         │ Example: CoffeeDecorator│      │ Example: IObserver│
└───────────────┘              └────────────────┘               └──────────────────┘
        │                                │                                │
        ▼                                ▼                                ▼
┌───────────────┐              ┌────────────────┐               ┌──────────────────┐
│ Abstract Factory 🧰 │        │ Facade 🚪      │               │ Command 🧾       │
│ Related families │           │ Simplify subsystems│           │ Encapsulate action│
│ Example: UIFactory│          │ Example: PaymentFacade│         │ Example: LightOnCmd│
└───────────────┘              └────────────────┘               └──────────────────┘
        │                                │                                │
        ▼                                ▼                                ▼
┌───────────────┐              ┌────────────────┐               ┌──────────────────┐
│ Builder 🧱     │              │ Proxy 🕵️&zwj;♂️     │               │ Chain of Resp. 🔗│
│ Stepwise build │              │ Control access │               │ Pass request along│
│ Example: ReportBuilder│      │ Example: ImageProxy│           │ Example: HandlerChain│
└───────────────┘              └────────────────┘               └──────────────────┘
        │
        ▼
┌───────────────┐
│ Prototype 🧬  │
│ Clone objects │
│ Example: Shape.Clone()│
└───────────────┘
</code></pre>
            <hr />
            <h1>📘 <strong>Summary Table &mdash; Design Patterns Overview</strong></h1>
            <table>
                <thead>
                    <tr>
                        <th>Type</th>
                        <th>Pattern</th>
                        <th>Core Idea</th>
                        <th>Example Use Case</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Creational</strong></td>
                        <td><strong>Singleton</strong></td>
                        <td>Only one instance shared</td>
                        <td>Logging service, config manager</td>
                    </tr>
                    <tr>
                        <td>&nbsp;</td>
                        <td><strong>Factory Method</strong></td>
                        <td>Delegate object creation</td>
                        <td>Payment processor, card factory</td>
                    </tr>
                    <tr>
                        <td>&nbsp;</td>
                        <td><strong>Abstract Factory</strong></td>
                        <td>Create families of related objects</td>
                        <td>UI components (Light/Dark theme)</td>
                    </tr>
                    <tr>
                        <td>&nbsp;</td>
                        <td><strong>Builder</strong></td>
                        <td>Construct complex objects step-by-step</td>
                        <td>Report generation, DTO builder</td>
                    </tr>
                    <tr>
                        <td>&nbsp;</td>
                        <td><strong>Prototype</strong></td>
                        <td>Clone existing instances</td>
                        <td>Game objects, UI elements</td>
                    </tr>
                    <tr>
                        <td><strong>Structural</strong></td>
                        <td><strong>Adapter</strong></td>
                        <td>Bridge incompatible interfaces</td>
                        <td>Legacy service integration</td>
                    </tr>
                    <tr>
                        <td>&nbsp;</td>
                        <td><strong>Decorator</strong></td>
                        <td>Add new behavior dynamically</td>
                        <td>Adding discount/tax to invoices</td>
                    </tr>
                    <tr>
                        <td>&nbsp;</td>
                        <td><strong>Facade</strong></td>
                        <td>Simplify complex subsystems</td>
                        <td>Unified API gateway</td>
                    </tr>
                    <tr>
                        <td>&nbsp;</td>
                        <td><strong>Proxy</strong></td>
                        <td>Control access or lazy-load</td>
                        <td>Virtual proxy for images or cache</td>
                    </tr>
                    <tr>
                        <td><strong>Behavioral</strong></td>
                        <td><strong>Strategy</strong></td>
                        <td>Swap algorithms at runtime</td>
                        <td>Payment methods (PayPal, Card)</td>
                    </tr>
                    <tr>
                        <td>&nbsp;</td>
                        <td><strong>Observer</strong></td>
                        <td>Notify subscribers on changes</td>
                        <td>Event-driven systems, UI updates</td>
                    </tr>
                    <tr>
                        <td>&nbsp;</td>
                        <td><strong>Command</strong></td>
                        <td>Encapsulate operations as objects</td>
                        <td>Undo/Redo functionality</td>
                    </tr>
                    <tr>
                        <td>&nbsp;</td>
                        <td><strong>Chain of Responsibility</strong></td>
                        <td>Pass request along handlers</td>
                        <td>Middleware, logging pipeline</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h1>🧠 <strong>Quick Mnemonics for Revision</strong></h1>
            <table>
                <thead>
                    <tr>
                        <th>Category</th>
                        <th>Memory Hook</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Creational &rarr; &ldquo;S.F.A.B.P.&rdquo;</strong></td>
                        <td>Singleton, Factory, Abstract Factory, Builder, Prototype</td>
                    </tr>
                    <tr>
                        <td><strong>Structural &rarr; &ldquo;A.D.F.P.&rdquo;</strong></td>
                        <td>Adapter, Decorator, Facade, Proxy</td>
                    </tr>
                    <tr>
                        <td><strong>Behavioral &rarr; &ldquo;S.O.C.C.&rdquo;</strong></td>
                        <td>Strategy, Observer, Command, Chain of Responsibility</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h1>💡 <strong>Most Commonly Used in .NET Core Projects</strong></h1>
            <table>
                <thead>
                    <tr>
                        <th>Pattern</th>
                        <th>Why It&rsquo;s Common</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Singleton</strong></td>
                        <td>For services like logging, configuration, or caching.</td>
                    </tr>
                    <tr>
                        <td><strong>Factory / Abstract Factory</strong></td>
                        <td>Used in Dependency Injection and repository creation.</td>
                    </tr>
                    <tr>
                        <td><strong>Strategy</strong></td>
                        <td>For dynamic business logic or algorithm selection.</td>
                    </tr>
                    <tr>
                        <td><strong>Decorator</strong></td>
                        <td>For extending middleware, adding caching, or validation.</td>
                    </tr>
                    <tr>
                        <td><strong>Observer</strong></td>
                        <td>For event-based systems and notification hubs.</td>
                    </tr>
                    <tr>
                        <td><strong>Chain of Responsibility</strong></td>
                        <td>ASP.NET Core middleware pattern is built on this.</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h1>🧾 <strong>Visual Flow &mdash; ASP.NET Core Example Mapping</strong></h1>
<pre><code>Incoming Request
    │
    ▼
[Middleware Pipeline] &rarr; Chain of Responsibility
    │
    ▼
[Controller] &rarr; Strategy / Factory / Decorator patterns
    │
    ▼
[Repository / Service Layer] &rarr; Singleton / Abstract Factory
    │
    ▼
[Domain Events] &rarr; Observer pattern
</code></pre>
            <hr />
            <p>✅ <strong>Final Takeaway:</strong></p>
            <blockquote>
                <p>Design patterns aren&rsquo;t just theory &mdash; they&rsquo;re <strong>building blocks</strong> of clean, scalable architecture.<br /> Mastering them helps you <strong>recognize problems early</strong> and <strong>choose proven solutions</strong> rather than reinventing the wheel.</p>
            </blockquote>
            <hr />
            <h2>🧩 .NET DESIGN PATTERNS &mdash; COMPLETE GUIDEBOOK</h2>
            <hr />
            <h1>🏗️ 1. CREATIONAL PATTERNS</h1>
            <blockquote>
                <p><strong>Focus:</strong> Object creation &mdash; when, how, and who creates them.</p>
            </blockquote>
            <hr />
            <h2><strong>1.1 Singleton Pattern</strong></h2>
            <p><strong>Purpose:</strong> Ensure only <strong>one instance</strong> of a class exists and provide a global access point.</p>
            <p><strong>Real-World Example:</strong><br /> <code>ConfigurationManager</code>, <code>ILogger</code>, <code>CacheService</code> in .NET Core.</p>
            <p><strong>C# Example:</strong></p>
<pre><code class="language-csharp">public sealed class Logger
{
    private static readonly Logger _instance = new Logger();
    private Logger() { }
    public static Logger Instance =&gt; _instance;
    public void Log(string msg) =&gt; Console.WriteLine(msg);
}
</code></pre>
            <p><strong>UML:</strong></p>
<pre><code>Client &rarr; Logger (static Instance)
</code></pre>
            <hr />
            <h2><strong>1.2 Factory Method</strong></h2>
            <p><strong>Purpose:</strong> Define an interface for creating objects but let subclasses decide which class to instantiate.</p>
            <p><strong>C# Example:</strong></p>
<pre><code class="language-csharp">public abstract class Notification
{
    public abstract void Notify(string message);
}

public class EmailNotification : Notification
{
    public override void Notify(string message) =&gt; Console.WriteLine($"Email: {message}");
}

public class SmsNotification : Notification
{
    public override void Notify(string message) =&gt; Console.WriteLine($"SMS: {message}");
}

public class NotificationFactory
{
    public static Notification Create(string type) =&gt; type switch
    {
        "email" =&gt; new EmailNotification(),
        "sms" =&gt; new SmsNotification(),
        _ =&gt; throw new ArgumentException("Invalid type")
    };
}
</code></pre>
            <p><strong>UML:</strong></p>
<pre><code>Factory &rarr; ConcreteProduct
</code></pre>
            <hr />
            <h2><strong>1.3 Abstract Factory</strong></h2>
            <p><strong>Purpose:</strong> Create <strong>families of related objects</strong> without specifying their concrete classes.</p>
            <p><strong>Example:</strong><br /> Cross-platform UI toolkit (Windows vs Mac).</p>
            <p><strong>C# Example:</strong></p>
<pre><code class="language-csharp">public interface IButton { void Paint(); }
public interface ICheckbox { void Paint(); }

public class WinButton : IButton { public void Paint() =&gt; Console.WriteLine("Windows Button"); }
public class MacButton : IButton { public void Paint() =&gt; Console.WriteLine("Mac Button"); }

public interface IGUIFactory
{
    IButton CreateButton();
    ICheckbox CreateCheckbox();
}

public class WinFactory : IGUIFactory
{
    public IButton CreateButton() =&gt; new WinButton();
    public ICheckbox CreateCheckbox() =&gt; new MacButton();
}
</code></pre>
            <hr />
            <h2><strong>1.4 Builder Pattern</strong></h2>
            <p><strong>Purpose:</strong> Build complex objects step-by-step.</p>
            <p><strong>Example:</strong><br /> Building a report, HTTP request, or configuration object.</p>
            <p><strong>C# Example:</strong></p>
<pre><code class="language-csharp">public class Report
{
    public string Title { get; set; }
    public string Body { get; set; }
}

public class ReportBuilder
{
    private Report _report = new();

    public ReportBuilder AddTitle(string title)
    {
        _report.Title = title;
        return this;
    }

    public ReportBuilder AddBody(string body)
    {
        _report.Body = body;
        return this;
    }

    public Report Build() =&gt; _report;
}
</code></pre>
            <hr />
            <h2><strong>1.5 Prototype Pattern</strong></h2>
            <p><strong>Purpose:</strong> Clone existing objects without depending on their classes.</p>
            <p><strong>C# Example:</strong></p>
<pre><code class="language-csharp">public class Employee : ICloneable
{
    public string Name { get; set; }
    public string Department { get; set; }
    public object Clone() =&gt; MemberwiseClone();
}
</code></pre>
            <hr />
            <h1>🧱 2. STRUCTURAL PATTERNS</h1>
            <blockquote>
                <p><strong>Focus:</strong> How classes and objects are composed to form larger structures.</p>
            </blockquote>
            <hr />
            <h2><strong>2.1 Adapter Pattern</strong></h2>
            <p><strong>Purpose:</strong> Convert one interface into another.</p>
            <p><strong>Example:</strong><br /> Adapting an old logging system to a new logging interface.</p>
            <p><strong>C# Example:</strong></p>
<pre><code class="language-csharp">public interface ILogger { void Log(string message); }

public class LegacyLogger { public void WriteLog(string msg) =&gt; Console.WriteLine($"Legacy: {msg}"); }

public class LoggerAdapter : ILogger
{
    private readonly LegacyLogger _legacy = new();
    public void Log(string message) =&gt; _legacy.WriteLog(message);
}
</code></pre>
            <hr />
            <h2><strong>2.2 Decorator Pattern</strong></h2>
            <p><strong>Purpose:</strong> Add new behavior to existing objects dynamically.</p>
            <p><strong>Example:</strong><br /> Extending middleware or response processing in ASP.NET Core.</p>
            <p><strong>C# Example:</strong></p>
<pre><code class="language-csharp">public interface IMessage
{
    string GetContent();
}

public class SimpleMessage : IMessage
{
    public string GetContent() =&gt; "Hello";
}

public class EncryptedMessage : IMessage
{
    private readonly IMessage _message;
    public EncryptedMessage(IMessage message) =&gt; _message = message;
    public string GetContent() =&gt; _message.GetContent() + " [Encrypted]";
}
</code></pre>
            <hr />
            <h2><strong>2.3 Facade Pattern</strong></h2>
            <p><strong>Purpose:</strong> Provide a simple interface to a complex subsystem.</p>
            <p><strong>Example:</strong><br /> API Gateway or Service Layer.</p>
            <p><strong>C# Example:</strong></p>
<pre><code class="language-csharp">public class OrderFacade
{
    private readonly Payment _payment = new();
    private readonly Inventory _inventory = new();
    private readonly Shipping _shipping = new();

    public void PlaceOrder()
    {
        _inventory.CheckStock();
        _payment.Process();
        _shipping.Ship();
    }
}
</code></pre>
            <hr />
            <h2><strong>2.4 Proxy Pattern</strong></h2>
            <p><strong>Purpose:</strong> Control access to an object.</p>
            <p><strong>Example:</strong><br /> Virtual Proxy for lazy-loading images.</p>
            <p><strong>C# Example:</strong></p>
<pre><code class="language-csharp">public interface IImage { void Display(); }

public class RealImage : IImage
{
    private string _file;
    public RealImage(string file) { _file = file; LoadFromDisk(); }
    private void LoadFromDisk() =&gt; Console.WriteLine($"Loading {_file}");
    public void Display() =&gt; Console.WriteLine($"Displaying {_file}");
}

public class ProxyImage : IImage
{
    private RealImage _real;
    private string _file;
    public ProxyImage(string file) =&gt; _file = file;
    public void Display()
    {
        _real ??= new RealImage(_file);
        _real.Display();
    }
}
</code></pre>
            <hr />
            <h1>⚙️ 3. BEHAVIORAL PATTERNS</h1>
            <blockquote>
                <p><strong>Focus:</strong> Communication between objects and how responsibilities are distributed.</p>
            </blockquote>
            <hr />
            <h2><strong>3.1 Strategy Pattern</strong></h2>
            <p><strong>Purpose:</strong> Define a family of algorithms and make them interchangeable.</p>
            <p><strong>Example:</strong><br /> Different payment methods in an e-commerce system.</p>
            <p><strong>C# Example:</strong></p>
<pre><code class="language-csharp">public interface IPaymentStrategy { void Pay(double amount); }
public class PayPalPayment : IPaymentStrategy { public void Pay(double amt) =&gt; Console.WriteLine($"Paid {amt} by PayPal"); }
public class CreditCardPayment : IPaymentStrategy { public void Pay(double amt) =&gt; Console.WriteLine($"Paid {amt} by Card"); }

public class PaymentContext
{
    private readonly IPaymentStrategy _strategy;
    public PaymentContext(IPaymentStrategy strategy) =&gt; _strategy = strategy;
    public void Execute(double amount) =&gt; _strategy.Pay(amount);
}
</code></pre>
            <hr />
            <h2><strong>3.2 Observer Pattern</strong></h2>
            <p><strong>Purpose:</strong> Notify multiple objects when a subject changes state.</p>
            <p><strong>Example:</strong><br /> Event-driven systems, Notification hubs, SignalR.</p>
            <p><strong>C# Example:</strong></p>
<pre><code class="language-csharp">public interface IObserver { void Update(string message); }
public class Subscriber : IObserver
{
    private readonly string _name;
    public Subscriber(string name) =&gt; _name = name;
    public void Update(string message) =&gt; Console.WriteLine($"{_name} received: {message}");
}

public class Channel
{
    private readonly List&lt;IObserver&gt; _subscribers = new();
    public void Subscribe(IObserver observer) =&gt; _subscribers.Add(observer);
    public void Notify(string message) { foreach (var sub in _subscribers) sub.Update(message); }
}
</code></pre>
            <hr />
            <h2><strong>3.3 Command Pattern</strong></h2>
            <p><strong>Purpose:</strong> Encapsulate requests as objects.</p>
            <p><strong>Example:</strong><br /> Undo/Redo, Queueing requests.</p>
            <p><strong>C# Example:</strong></p>
<pre><code class="language-csharp">public interface ICommand { void Execute(); }

public class Light
{
    public void On() =&gt; Console.WriteLine("Light On");
    public void Off() =&gt; Console.WriteLine("Light Off");
}

public class LightOnCommand : ICommand
{
    private readonly Light _light;
    public LightOnCommand(Light light) =&gt; _light = light;
    public void Execute() =&gt; _light.On();
}
</code></pre>
            <hr />
            <h2><strong>3.4 Chain of Responsibility Pattern</strong></h2>
            <p><strong>Purpose:</strong> Pass requests along a chain of handlers.</p>
            <p><strong>Example:</strong><br /> ASP.NET Core Middleware.</p>
            <p><strong>C# Example:</strong></p>
<pre><code class="language-csharp">public abstract class Handler
{
    protected Handler _next;
    public Handler SetNext(Handler next) { _next = next; return next; }
    public abstract void Handle(string request);
}

public class AuthHandler : Handler
{
    public override void Handle(string request)
    {
        if (request.Contains("Auth")) Console.WriteLine("Authenticated");
        else _next?.Handle(request);
    }
}
</code></pre>
            <hr />
            <h2><strong>3.5 Iterator Pattern</strong></h2>
            <p><strong>Purpose:</strong> Access elements sequentially without exposing internal structure.</p>
            <p><strong>C# Example:</strong></p>
<pre><code class="language-csharp">public class NameCollection : IEnumerable&lt;string&gt;
{
    private readonly List&lt;string&gt; _names = new() { "Alice", "Bob", "Charlie" };
    public IEnumerator&lt;string&gt; GetEnumerator() { foreach (var n in _names) yield return n; }
    IEnumerator IEnumerable.GetEnumerator() =&gt; GetEnumerator();
}
</code></pre>
            <hr />
            <h2>✅ <strong>Summary Chart</strong></h2>
            <table>
                <thead>
                    <tr>
                        <th>Category</th>
                        <th>Patterns</th>
                        <th>Common .NET Usage</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Creational</strong></td>
                        <td>Singleton, Factory, Abstract Factory, Builder, Prototype</td>
                        <td>DI, Configs</td>
                    </tr>
                    <tr>
                        <td><strong>Structural</strong></td>
                        <td>Adapter, Decorator, Facade, Proxy</td>
                        <td>Middleware, Services</td>
                    </tr>
                    <tr>
                        <td><strong>Behavioral</strong></td>
                        <td>Strategy, Observer, Command, Chain of Responsibility, Iterator</td>
                        <td>Eventing, Middleware, Business Logic</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h1>🧩 <strong>CREATIONAL DESIGN PATTERNS &mdash; UML OVERVIEW</strong></h1>
<pre><code>                ┌──────────────────────────────┐
                │      CREATIONAL PATTERNS 🏗️   │
                └──────────────┬───────────────┘
                               │
 ┌───────────────────────────────────────────────────────────────┐
 │  Purpose: Object creation mechanisms, abstracting instantiation│
 └───────────────────────────────────────────────────────────────┘

   ┌─────────────────────────────────────────────────────────────┐
   │ 1️⃣ Singleton Pattern                                       │
   └─────────────────────────────────────────────────────────────┘
        ┌──────────────────────────┐
        │        Logger            │
        │  - static Instance       │
        │  - private constructor   │
        │  + GetInstance()         │
        └──────────┬───────────────┘
                   │
                   ▼
               [Client]

------------------------------------------------------------

   ┌─────────────────────────────────────────────────────────────┐
   │ 2️⃣ Factory Method Pattern                                  │
   └─────────────────────────────────────────────────────────────┘
        [Creator] ──▶ defines factoryMethod() ──▶ returns [Product]
        [ConcreteCreator] ──▶ overrides factoryMethod()
        [ConcreteProduct] ──▶ implements [Product]

------------------------------------------------------------

   ┌─────────────────────────────────────────────────────────────┐
   │ 3️⃣ Abstract Factory Pattern                                │
   └─────────────────────────────────────────────────────────────┘
        ┌────────────┐     ┌──────────────┐
        │ GUIFactory │───▶│ ButtonFactory│
        └────┬───────┘     └────┬────────┘
             │                  │
     ┌───────▼───────┐   ┌──────▼────────┐
     │ WinFactory    │   │ MacFactory    │
     └───────────────┘   └───────────────┘
             │                  │
     ┌───────▼───────┐   ┌──────▼────────┐
     │ WinButton     │   │ MacButton     │
     └───────────────┘   └───────────────┘

------------------------------------------------------------

   ┌─────────────────────────────────────────────────────────────┐
   │ 4️⃣ Builder Pattern                                         │
   └─────────────────────────────────────────────────────────────┘
        [Director] ──▶ uses ──▶ [Builder] ──▶ builds ──▶ [Product]
        Example: ReportBuilder builds Report step by step.

------------------------------------------------------------

   ┌─────────────────────────────────────────────────────────────┐
   │ 5️⃣ Prototype Pattern                                       │
   └─────────────────────────────────────────────────────────────┘
        [Client] ──▶ calls clone() ──▶ [Prototype] ──▶ creates copy
</code></pre>
            <hr />
            <h1>🧱 <strong>STRUCTURAL DESIGN PATTERNS &mdash; UML OVERVIEW</strong></h1>
<pre><code>                ┌──────────────────────────────┐
                │     STRUCTURAL PATTERNS 🧱    │
                └──────────────┬───────────────┘
                               │
 ┌───────────────────────────────────────────────────────────────┐
 │  Purpose: Organize objects/classes into larger structures      │
 └───────────────────────────────────────────────────────────────┘

   ┌─────────────────────────────────────────────────────────────┐
   │ 1️⃣ Adapter Pattern                                         │
   └─────────────────────────────────────────────────────────────┘
        [Client] &rarr; [Adapter] &rarr; [Adaptee]
        Example: NewLogger &rarr; LoggerAdapter &rarr; LegacyLogger

------------------------------------------------------------

   ┌─────────────────────────────────────────────────────────────┐
   │ 2️⃣ Decorator Pattern                                       │
   └─────────────────────────────────────────────────────────────┘
        [Component] &lt;── implemented by ── [ConcreteComponent]
             ▲
             │
             ├── wrapped by [Decorator]
             │
             └── wrapped by [ConcreteDecorator]
        Example: Coffee &rarr; MilkDecorator &rarr; SugarDecorator

------------------------------------------------------------

   ┌─────────────────────────────────────────────────────────────┐
   │ 3️⃣ Facade Pattern                                          │
   └─────────────────────────────────────────────────────────────┘
        [Client] ──▶ [Facade] ──▶ [Subsystem A]
                                 ├──▶ [Subsystem B]
                                 └──▶ [Subsystem C]
        Example: OrderFacade calls Payment + Shipping + Inventory.

------------------------------------------------------------

   ┌─────────────────────────────────────────────────────────────┐
   │ 4️⃣ Proxy Pattern                                           │
   └─────────────────────────────────────────────────────────────┘
        [Client] ──▶ [Proxy] ──▶ [RealSubject]
        Example: ImageProxy loads RealImage on demand.
</code></pre>
            <hr />
            <h1>⚙️ <strong>BEHAVIORAL DESIGN PATTERNS &mdash; UML OVERVIEW</strong></h1>
<pre><code>                ┌──────────────────────────────┐
                │   BEHAVIORAL PATTERNS ⚙️     │
                └──────────────┬───────────────┘
                               │
 ┌───────────────────────────────────────────────────────────────┐
 │  Purpose: Manage communication and responsibilities between   │
 │  objects.                                                     │
 └───────────────────────────────────────────────────────────────┘

   ┌─────────────────────────────────────────────────────────────┐
   │ 1️⃣ Strategy Pattern                                        │
   └─────────────────────────────────────────────────────────────┘
        [Context] ──▶ uses ──▶ [Strategy Interface]
                                │
                                ├──▶ [ConcreteStrategyA]
                                └──▶ [ConcreteStrategyB]
        Example: PaymentContext uses PayPalStrategy or CardStrategy.

------------------------------------------------------------

   ┌─────────────────────────────────────────────────────────────┐
   │ 2️⃣ Observer Pattern                                        │
   └─────────────────────────────────────────────────────────────┘
        [Subject] ──▶ maintains ──▶ [Observers]
                         │
                         ├──▶ notify() all observers
        Example: YouTube Channel &rarr; Users get notifications.

------------------------------------------------------------

   ┌─────────────────────────────────────────────────────────────┐
   │ 3️⃣ Command Pattern                                         │
   └─────────────────────────────────────────────────────────────┘
        [Invoker] ──▶ [Command Interface] ──▶ [Receiver]
             │
             └──▶ holds command history for undo/redo
        Example: RemoteControl executes LightOnCommand.

------------------------------------------------------------

   ┌─────────────────────────────────────────────────────────────┐
   │ 4️⃣ Chain of Responsibility Pattern                         │
   └─────────────────────────────────────────────────────────────┘
        [Handler1] ──▶ [Handler2] ──▶ [Handler3]
             │
             └── passes request down the chain
        Example: Middleware pipeline in ASP.NET Core.

------------------------------------------------------------

   ┌─────────────────────────────────────────────────────────────┐
   │ 5️⃣ Iterator Pattern                                       │
   └─────────────────────────────────────────────────────────────┘
        [Aggregate] ──▶ creates ──▶ [Iterator]
                               │
                               └──▶ traverses elements sequentially
        Example: IEnumerable&lt;T&gt; and foreach in .NET.
</code></pre>
            <hr />
            <h1>🧭 <strong>FINAL DESIGN PATTERN MAP</strong></h1>
<pre><code>                      ┌────────────────────────────┐
                      │       DESIGN PATTERNS      │
                      └────────────┬───────────────┘
                                   │
      ┌────────────────────────────┼─────────────────────────────┐
      │                            │                             │
      ▼                            ▼                             ▼
┌──────────────┐           ┌──────────────┐               ┌──────────────┐
│ CREATIONAL 🏗️│           │ STRUCTURAL 🧱│               │ BEHAVIORAL ⚙️│
└──────────────┘           └──────────────┘               └──────────────┘
│ Singleton                │ Adapter                     │ Strategy
│ Factory Method           │ Decorator                   │ Observer
│ Abstract Factory         │ Facade                      │ Command
│ Builder                  │ Proxy                       │ Chain of Resp.
│ Prototype                │ Composite/Bridge (optional)  │ Iterator
</code></pre>
            <hr />
            <h1>✅ <strong>How to Remember Them Easily</strong></h1>
            <table>
                <thead>
                    <tr>
                        <th>Category</th>
                        <th>Mnemonic</th>
                        <th>Focus</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Creational</strong></td>
                        <td><strong>S.F.A.B.P.</strong></td>
                        <td>How objects are created</td>
                    </tr>
                    <tr>
                        <td><strong>Structural</strong></td>
                        <td><strong>A.D.F.P.</strong></td>
                        <td>How objects are composed</td>
                    </tr>
                    <tr>
                        <td><strong>Behavioral</strong></td>
                        <td><strong>S.O.C.C.I.</strong></td>
                        <td>How objects communicate</td>
                    </tr>
                </tbody>
            </table>
            <hr />
        </div>
    </TabPage>
    <TabPage Title="Entity Framework">
        <div class="content">
            <h1>🧩 <strong>Entity Framework Core &mdash; Full Guide (Basic to Advanced)</strong></h1>
            <hr />
            <h2>🧠 1️⃣ What is Entity Framework Core?</h2>
            <p><strong>Definition:</strong><br /> Entity Framework Core (EF Core) is Microsoft&rsquo;s <strong>Object-Relational Mapper (ORM)</strong> that allows developers to:</p>
            <ul>
                <li>
                    <p>Work with <strong>databases using C# classes</strong> instead of SQL queries.</p>
                </li>
                <li>
                    <p>Handle <strong>CRUD operations</strong> (Create, Read, Update, Delete) automatically.</p>
                </li>
                <li>
                    <p>Map <strong>objects &harr; database tables</strong>.</p>
                </li>
            </ul>
            <p>✅ Think of EF Core as the &ldquo;translator&rdquo; between your <strong>C# objects</strong> and <strong>database tables</strong>.</p>
            <hr />
            <h2>⚙️ 2️⃣ How EF Core Works &mdash; The Architecture</h2>
<pre><code>[ Your C# Code ]
        │
        ▼
[ DbContext ] &mdash; main bridge between app and database
        │
        ▼
[ DbSet&lt;TEntity&gt; ] &mdash; represents a table
        │
        ▼
[ Database Provider (SQL Server, PostgreSQL, etc.) ]
        │
        ▼
[ Database ]
</code></pre>
            <hr />
            <h2>🧾 3️⃣ Basic Concepts</h2>
            <h3>🔹 <strong>DbContext</strong></h3>
            <ul>
                <li>
                    <p>Represents a <strong>session</strong> with the database.</p>
                </li>
                <li>
                    <p>Manages <strong>entities</strong>, <strong>queries</strong>, and <strong>transactions</strong>.</p>
                </li>
            </ul>
<pre><code class="language-csharp">public class AppDbContext : DbContext
{
    public DbSet&lt;Employee&gt; Employees { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder options)
    {
        options.UseSqlServer("Server=.;Database=HRDB;Trusted_Connection=True;");
    }
}
</code></pre>
            <hr />
            <h3>🔹 <strong>Entity / Model</strong></h3>
            <p>Represents a <strong>table</strong> in the database.</p>
<pre><code class="language-csharp">public class Employee
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Department { get; set; }
}
</code></pre>
            <hr />
            <h3>🔹 <strong>DbSet</strong></h3>
            <p>Acts like a <strong>table</strong>, enabling LINQ queries and CRUD operations.</p>
<pre><code class="language-csharp">var employees = context.Employees.ToList();   // SELECT * FROM Employees
</code></pre>
            <hr />
            <h3>🔹 <strong>CRUD Operations</strong></h3>
<pre><code class="language-csharp">// CREATE
context.Employees.Add(new Employee { Name = "John", Department = "IT" });
context.SaveChanges();

// READ
var emp = context.Employees.FirstOrDefault(e =&gt; e.Id == 1);

// UPDATE
emp.Department = "HR";
context.SaveChanges();

// DELETE
context.Employees.Remove(emp);
context.SaveChanges();
</code></pre>
            <hr />
            <h2>🧭 4️⃣ Data Modeling Approaches</h2>
            <table>
                <thead>
                    <tr>
                        <th>Approach</th>
                        <th>Description</th>
                        <th>When to Use</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Code-First</strong></td>
                        <td>Define models in C#, EF creates DB</td>
                        <td>Greenfield projects</td>
                    </tr>
                    <tr>
                        <td><strong>Database-First</strong></td>
                        <td>Start from existing DB, EF generates models</td>
                        <td>Legacy systems</td>
                    </tr>
                    <tr>
                        <td><strong>Model-First</strong></td>
                        <td>Design model visually, EF generates DB</td>
                        <td>Rarely used</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>🧱 5️⃣ Migrations (Schema Evolution)</h2>
            <p><strong>Purpose:</strong><br /> When you change your C# model, EF can <strong>update the database schema</strong> automatically.</p>
            <h3>Commands:</h3>
<pre><code class="language-bash">dotnet ef migrations add InitialCreate
dotnet ef database update
</code></pre>
            <h3>Example:</h3>
            <p>Add a new property to your model:</p>
<pre><code class="language-csharp">public string Email { get; set; }
</code></pre>
            <p>Then run migrations again to update the DB.</p>
            <hr />
            <h2>⚡ 6️⃣ Querying Data</h2>
            <p>EF Core uses <strong>LINQ (Language Integrated Query)</strong> to interact with the database.</p>
            <h3>Examples:</h3>
<pre><code class="language-csharp">// Simple query
var all = context.Employees.ToList();

// Filter
var itDept = context.Employees.Where(e =&gt; e.Department == "IT");

// Projection
var names = context.Employees.Select(e =&gt; e.Name);

// Join
var query = from e in context.Employees
            join d in context.Departments on e.DepartmentId equals d.Id
            select new { e.Name, d.Name };
</code></pre>
            <p>✅ <strong>LINQ &rarr; SQL Translation:</strong><br /> EF Core automatically converts LINQ to <strong>parameterized SQL</strong>.</p>
            <hr />
            <h2>💾 7️⃣ Tracking vs No-Tracking</h2>
            <p><strong>Tracking</strong> = EF monitors changes to objects &rarr; used for updates.<br /> <strong>No-Tracking</strong> = faster queries (read-only).</p>
<pre><code class="language-csharp">var emp = context.Employees.AsNoTracking().FirstOrDefault(e =&gt; e.Id == 1);
</code></pre>
            <p>✅ <strong>Use AsNoTracking()</strong> for queries that don&rsquo;t need updates &mdash; improves performance.</p>
            <hr />
            <h2>⚙️ 8️⃣ Relationships &amp; Navigation Properties</h2>
            <h3>🔸 One-to-Many Example</h3>
<pre><code class="language-csharp">public class Department
{
    public int Id { get; set; }
    public string Name { get; set; }
    public List&lt;Employee&gt; Employees { get; set; }
}

public class Employee
{
    public int Id { get; set; }
    public string Name { get; set; }
    public int DepartmentId { get; set; }
    public Department Department { get; set; }
}
</code></pre>
            <h3>🔸 Fluent API (In DbContext)</h3>
<pre><code class="language-csharp">protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity&lt;Employee&gt;()
        .HasOne(e =&gt; e.Department)
        .WithMany(d =&gt; d.Employees)
        .HasForeignKey(e =&gt; e.DepartmentId);
}
</code></pre>
            <hr />
            <h2>⚡ 9️⃣ Lazy Loading, Eager Loading, Explicit Loading</h2>
            <table>
                <thead>
                    <tr>
                        <th>Type</th>
                        <th>Description</th>
                        <th>Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Eager</strong></td>
                        <td>Load related data immediately</td>
                        <td><code>.Include(e =&gt; e.Department)</code></td>
                    </tr>
                    <tr>
                        <td><strong>Lazy</strong></td>
                        <td>Loads related data only when accessed</td>
                        <td>needs <code>Microsoft.EntityFrameworkCore.Proxies</code></td>
                    </tr>
                    <tr>
                        <td><strong>Explicit</strong></td>
                        <td>Manual control over loading</td>
                        <td><code>context.Entry(emp).Reference(e =&gt; e.Department).Load();</code></td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>🧠 1️⃣0️⃣ Change Tracking</h2>
            <p>EF Core <strong>tracks entity states</strong>:</p>
            <table>
                <thead>
                    <tr>
                        <th>State</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>Added</code></td>
                        <td>New entity to insert</td>
                    </tr>
                    <tr>
                        <td><code>Modified</code></td>
                        <td>Entity has been changed</td>
                    </tr>
                    <tr>
                        <td><code>Deleted</code></td>
                        <td>Entity marked for deletion</td>
                    </tr>
                    <tr>
                        <td><code>Unchanged</code></td>
                        <td>No modifications</td>
                    </tr>
                    <tr>
                        <td><code>Detached</code></td>
                        <td>Not tracked by context</td>
                    </tr>
                </tbody>
            </table>
<pre><code class="language-csharp">context.Entry(emp).State = EntityState.Modified;
context.SaveChanges();
</code></pre>
            <hr />
            <h2>🧩 1️⃣1️⃣ Concurrency Handling</h2>
            <p>EF Core supports <strong>Optimistic Concurrency</strong> using <code>RowVersion</code> or <code>Timestamp</code>.</p>
<pre><code class="language-csharp">public byte[] RowVersion { get; set; }
</code></pre>
            <p>When two users modify the same row &rarr; EF detects conflict and throws <code>DbUpdateConcurrencyException</code>.</p>
            <hr />
            <h2>⚙️ 1️⃣2️⃣ Transactions</h2>
            <p>You can manually control transactions:</p>
<pre><code class="language-csharp">using var transaction = context.Database.BeginTransaction();
try
{
    // Multiple SaveChanges
    context.SaveChanges();
    transaction.Commit();
}
catch
{
    transaction.Rollback();
}
</code></pre>
            <hr />
            <h2>⚡ 1️⃣3️⃣ Advanced Topics</h2>
            <h3>🧩 a) Global Query Filters</h3>
            <p>Apply global filters (e.g., soft delete, multi-tenancy):</p>
<pre><code class="language-csharp">modelBuilder.Entity&lt;Employee&gt;()
    .HasQueryFilter(e =&gt; !e.IsDeleted);
</code></pre>
            <hr />
            <h3>🧩 b) Shadow Properties</h3>
            <p>Properties not in the model class but exist in DB:</p>
<pre><code class="language-csharp">modelBuilder.Entity&lt;Employee&gt;().Property&lt;DateTime&gt;("CreatedAt");
</code></pre>
            <hr />
            <h3>🧩 c) Interceptors</h3>
            <p>Used to log, modify, or audit SQL commands.</p>
<pre><code class="language-csharp">public class LoggingInterceptor : DbCommandInterceptor
{
    public override InterceptionResult&lt;int&gt; NonQueryExecuting(
        DbCommand command, CommandEventData eventData, InterceptionResult&lt;int&gt; result)
    {
        Console.WriteLine(command.CommandText);
        return base.NonQueryExecuting(command, eventData, result);
    }
}
</code></pre>
            <p>Register:</p>
<pre><code class="language-csharp">options.AddInterceptors(new LoggingInterceptor());
</code></pre>
            <hr />
            <h3>🧩 d) Raw SQL Queries</h3>
            <p>Execute SQL directly (still mapped to entities):</p>
<pre><code class="language-csharp">var employees = context.Employees
    .FromSqlRaw("SELECT * FROM Employees WHERE Department = 'IT'")
    .ToList();
</code></pre>
            <hr />
            <h3>🧩 e) Performance Optimizations</h3>
            <table>
                <thead>
                    <tr>
                        <th>Technique</th>
                        <th>Purpose</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>AsNoTracking()</strong></td>
                        <td>Skip change tracking for read-only</td>
                    </tr>
                    <tr>
                        <td><strong>Split Queries</strong></td>
                        <td>Avoid Cartesian explosion</td>
                    </tr>
                    <tr>
                        <td><strong>Compiled Queries</strong></td>
                        <td>Cache SQL for repeated use</td>
                    </tr>
                    <tr>
                        <td><strong>Connection Pooling</strong></td>
                        <td>Reuse connections</td>
                    </tr>
                    <tr>
                        <td><strong>Batch Updates</strong></td>
                        <td>Minimize round-trips</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h3>🧩 f) Caching</h3>
            <p>EF Core does not cache queries by default, but you can use:</p>
            <ul>
                <li>
                    <p><strong>Compiled Queries</strong></p>
                </li>
                <li>
                    <p><strong>MemoryCache / Redis</strong> for app-level caching.</p>
                </li>
            </ul>
            <hr />
            <h2>🧭 1️⃣4️⃣ EF Core in ASP.NET Core Architecture</h2>
<pre><code>[ Controller ]
      │
      ▼
[ Service / Repository Layer ]
      │
      ▼
[ DbContext (EF Core) ]
      │
      ▼
[ SQL Server / PostgreSQL / etc. ]
</code></pre>
            <p>EF Core can be registered via <strong>Dependency Injection</strong>:</p>
<pre><code class="language-csharp">services.AddDbContext&lt;AppDbContext&gt;(options =&gt;
    options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));
</code></pre>
            <hr />
            <h2>🧾 1️⃣5️⃣ EF Core Providers</h2>
            <table>
                <thead>
                    <tr>
                        <th>Provider</th>
                        <th>Package</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>SQL Server</td>
                        <td><code>Microsoft.EntityFrameworkCore.SqlServer</code></td>
                    </tr>
                    <tr>
                        <td>PostgreSQL</td>
                        <td><code>Npgsql.EntityFrameworkCore.PostgreSQL</code></td>
                    </tr>
                    <tr>
                        <td>MySQL</td>
                        <td><code>Pomelo.EntityFrameworkCore.MySql</code></td>
                    </tr>
                    <tr>
                        <td>SQLite</td>
                        <td><code>Microsoft.EntityFrameworkCore.Sqlite</code></td>
                    </tr>
                    <tr>
                        <td>InMemory</td>
                        <td><code>Microsoft.EntityFrameworkCore.InMemory</code></td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>🧠 1️⃣6️⃣ Common Interview Questions</h2>
            <table>
                <thead>
                    <tr>
                        <th>Question</th>
                        <th>Short Answer</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>What is EF Core?</td>
                        <td>ORM for .NET to map classes to DB.</td>
                    </tr>
                    <tr>
                        <td>Difference between EF &amp; EF Core?</td>
                        <td>EF Core is lightweight, cross-platform, modern.</td>
                    </tr>
                    <tr>
                        <td>What are migrations?</td>
                        <td>Track and apply schema changes.</td>
                    </tr>
                    <tr>
                        <td>What is <code>DbContext</code>?</td>
                        <td>Main class managing entity objects and DB communication.</td>
                    </tr>
                    <tr>
                        <td>What&rsquo;s <code>AsNoTracking()</code>?</td>
                        <td>Improves read performance by disabling tracking.</td>
                    </tr>
                    <tr>
                        <td>Eager vs Lazy loading?</td>
                        <td>Eager loads immediately, Lazy loads when accessed.</td>
                    </tr>
                    <tr>
                        <td>How do you handle concurrency?</td>
                        <td>Using <code>RowVersion</code> or <code>Timestamp</code>.</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h1>⚙️ <strong>EF Core Lifecycle &amp; Architecture &mdash; Detailed Visualization</strong></h1>
            <hr />
            <h2>🧩 1️⃣ The Big Picture</h2>
            <p>Think of EF Core as a pipeline that connects your <strong>C# code</strong> with your <strong>database</strong>:</p>
<pre><code>C# Classes &rarr; DbContext &rarr; LINQ Query &rarr; SQL Generation &rarr; Database &rarr; Result Materialization
</code></pre>
            <hr />
            <h2>🔍 <strong>EF Core Request Lifecycle</strong></h2>
<pre><code>┌──────────────────────────────────────────────────────────────┐
│                        EF CORE PIPELINE                      │
└──────────────────────────────────────────────────────────────┘
   │
   ▼
[1] Application Code (C#)
    └── You write: context.Employees.Where(e =&gt; e.Department == "IT")
   │
   ▼
[2] LINQ Provider
    └── EF Core intercepts the LINQ expression tree
        and translates it into SQL query syntax
   │
   ▼
[3] Query Compilation
    └── EF Core optimizes and compiles SQL
        &rarr; parameterized query to prevent SQL Injection
   │
   ▼
[4] Database Provider (SQL Server, PostgreSQL, etc.)
    └── Sends generated SQL to the actual database
   │
   ▼
[5] Database Engine
    └── Executes SQL and returns raw data (rows)
   │
   ▼
[6] Materialization
    └── EF Core maps raw data &rarr; C# entities (objects)
   │
   ▼
[7] Change Tracker
    └── EF Core tracks each entity&rsquo;s state (Added, Modified, Deleted)
   │
   ▼
[8] SaveChanges()
    └── EF Core converts tracked changes &rarr; SQL INSERT/UPDATE/DELETE
   │
   ▼
[9] Database Update
    └── Transaction executes; rows updated in DB
</code></pre>
            <hr />
            <h2>🧱 <strong>Step-by-Step Explanation</strong></h2>
            <hr />
            <h3>🔹 Step 1 &mdash; LINQ Query (C# Level)</h3>
            <p>You write:</p>
<pre><code class="language-csharp">var result = context.Employees.Where(e =&gt; e.Department == "IT").ToList();
</code></pre>
            <p>➡️ EF Core <strong>does not immediately query the database</strong>.<br /> It builds an <strong>Expression Tree</strong> &mdash; a representation of your query.</p>
            <hr />
            <h3>🔹 Step 2 &mdash; Translation Phase</h3>
            <p>EF Core uses the <strong>Database Provider</strong> (e.g., SQL Server provider) to translate the LINQ expression tree into <strong>SQL</strong>.</p>
            <p>Example generated SQL:</p>
<pre><code class="language-sql">SELECT [e].[Id], [e].[Name], [e].[Department]
FROM [Employees] AS [e]
WHERE [e].[Department] = __dept_0
</code></pre>
            <p>✅ <strong>Parameterization</strong> is automatic &mdash; helps prevent SQL Injection.</p>
            <hr />
            <h3>🔹 Step 3 &mdash; Query Execution</h3>
            <p>EF Core sends the SQL command to the database via <strong>ADO.NET</strong>.<br /> The database executes it and returns <strong>raw rows</strong>.</p>
            <hr />
            <h3>🔹 Step 4 &mdash; Materialization</h3>
            <p>EF Core reads the database results and converts each row into a <strong>C# object</strong> (<code>Employee</code>).</p>
<pre><code class="language-csharp">Employee e = new Employee { Id = 1, Name = "John", Department = "IT" };
</code></pre>
            <p>✅ This process is called <strong>Object Materialization</strong>.</p>
            <hr />
            <h3>🔹 Step 5 &mdash; Change Tracking</h3>
            <p>Once entities are loaded, EF Core&rsquo;s <strong>Change Tracker</strong> keeps track of their state.</p>
            <table>
                <thead>
                    <tr>
                        <th>Entity State</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Added</td>
                        <td>Newly created object (will INSERT)</td>
                    </tr>
                    <tr>
                        <td>Modified</td>
                        <td>Changed properties (will UPDATE)</td>
                    </tr>
                    <tr>
                        <td>Deleted</td>
                        <td>Marked for deletion (will DELETE)</td>
                    </tr>
                    <tr>
                        <td>Unchanged</td>
                        <td>No changes detected</td>
                    </tr>
                    <tr>
                        <td>Detached</td>
                        <td>Not tracked by context</td>
                    </tr>
                </tbody>
            </table>
            <p>Example:</p>
<pre><code class="language-csharp">emp.Department = "HR";
context.Entry(emp).State = EntityState.Modified;
</code></pre>
            <hr />
            <h3>🔹 Step 6 &mdash; SaveChanges() Execution</h3>
            <p>When you call <code>context.SaveChanges()</code>, EF Core performs these steps:</p>
<pre><code>1️⃣ Detects all tracked entities with changes.
2️⃣ Generates corresponding SQL (INSERT, UPDATE, DELETE).
3️⃣ Wraps them in a transaction.
4️⃣ Sends commands to the database.
</code></pre>
            <p>Example SQL generated:</p>
<pre><code class="language-sql">UPDATE [Employees]
SET [Department] = p0
WHERE [Id] = p1;
</code></pre>
            <hr />
            <h3>🔹 Step 7 &mdash; Transaction Handling</h3>
            <p>EF Core automatically wraps multiple database operations into a <strong>transaction</strong> to ensure <strong>atomicity</strong> &mdash; either all succeed or none.</p>
<pre><code class="language-csharp">using var transaction = context.Database.BeginTransaction();
context.SaveChanges();
transaction.Commit();
</code></pre>
            <hr />
            <h3>🔹 Step 8 &mdash; Detaching / Disposal</h3>
            <p>After SaveChanges(), you can:</p>
            <ul>
                <li>
                    <p>Keep entities tracked (default).</p>
                </li>
                <li>
                    <p>Or detach them to reduce memory usage:</p>
<pre><code class="language-csharp">context.Entry(emp).State = EntityState.Detached;
</code></pre>
                </li>
            </ul>
            <p>And when the request ends (in a web app), <strong>DbContext is disposed</strong> &mdash; freeing up connections.</p>
            <hr />
            <h2>⚙️ <strong>Visual Summary Diagram</strong></h2>
<pre><code>┌──────────────────────────────────────────────────────────────┐
│                      EF Core Internal Flow                   │
└──────────────────────────────────────────────────────────────┘
      C# Code (LINQ)
             │
             ▼
     Expression Tree
             │
             ▼
     Query Translator
             │
             ▼
     Database Provider
             │
             ▼
     SQL Command (ADO.NET)
             │
             ▼
     Database Engine
             │
             ▼
     Result Set (Rows)
             │
             ▼
     Object Materializer
             │
             ▼
     Entity Objects (Tracked)
             │
             ▼
     Change Tracker
             │
             ▼
     SaveChanges() &rarr; SQL (Insert/Update/Delete)
             │
             ▼
     Database Commit (Transaction)
</code></pre>
            <hr />
            <h2>⚡ <strong>Performance &amp; Lifecycle Optimization Tips</strong></h2>
            <table>
                <thead>
                    <tr>
                        <th>Concept</th>
                        <th>Description</th>
                        <th>Recommendation</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>DbContext Lifetime</strong></td>
                        <td>Short-lived, per request in web apps</td>
                        <td>Register as Scoped</td>
                    </tr>
                    <tr>
                        <td><strong>AsNoTracking()</strong></td>
                        <td>Skip tracking for read-only queries</td>
                        <td>Use for read APIs</td>
                    </tr>
                    <tr>
                        <td><strong>Compiled Queries</strong></td>
                        <td>Cache query plans</td>
                        <td>Use for repeated queries</td>
                    </tr>
                    <tr>
                        <td><strong>Lazy Loading</strong></td>
                        <td>Load only when accessed</td>
                        <td>Use carefully; prefer Eager</td>
                    </tr>
                    <tr>
                        <td><strong>Batch Operations</strong></td>
                        <td>Minimize DB round-trips</td>
                        <td>Use EFCore.BulkExtensions</td>
                    </tr>
                    <tr>
                        <td><strong>Transactions</strong></td>
                        <td>Combine multiple changes</td>
                        <td>Use <code>BeginTransaction()</code></td>
                    </tr>
                    <tr>
                        <td><strong>Connection Pooling</strong></td>
                        <td>Reuse database connections</td>
                        <td>Enabled by default</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>🧠 <strong>EF Core Internal Components</strong></h2>
            <table>
                <thead>
                    <tr>
                        <th>Component</th>
                        <th>Role</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>DbContext</strong></td>
                        <td>Manages connection and entities</td>
                    </tr>
                    <tr>
                        <td><strong>DbSet</strong></td>
                        <td>Represents database tables</td>
                    </tr>
                    <tr>
                        <td><strong>ModelBuilder</strong></td>
                        <td>Builds schema and relationships</td>
                    </tr>
                    <tr>
                        <td><strong>ChangeTracker</strong></td>
                        <td>Detects and tracks entity changes</td>
                    </tr>
                    <tr>
                        <td><strong>Database Provider</strong></td>
                        <td>Generates provider-specific SQL</td>
                    </tr>
                    <tr>
                        <td><strong>Migrations</strong></td>
                        <td>Handles schema evolution</td>
                    </tr>
                    <tr>
                        <td><strong>Interceptors</strong></td>
                        <td>Hooks for logging and auditing</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>🧾 <strong>Quick Recap</strong></h2>
            <table>
                <thead>
                    <tr>
                        <th>Stage</th>
                        <th>What Happens</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>LINQ Query</td>
                        <td>EF builds expression tree</td>
                    </tr>
                    <tr>
                        <td>Translation</td>
                        <td>Expression tree &rarr; SQL</td>
                    </tr>
                    <tr>
                        <td>Execution</td>
                        <td>SQL runs on DB</td>
                    </tr>
                    <tr>
                        <td>Materialization</td>
                        <td>Rows &rarr; C# objects</td>
                    </tr>
                    <tr>
                        <td>Tracking</td>
                        <td>Objects monitored for changes</td>
                    </tr>
                    <tr>
                        <td>SaveChanges()</td>
                        <td>Changes &rarr; SQL statements</td>
                    </tr>
                    <tr>
                        <td>Transaction</td>
                        <td>Commits all changes atomically</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>🧭 <strong>Example &mdash; Full Flow in Action</strong></h2>
<pre><code class="language-csharp">using var context = new AppDbContext();

// 1️⃣ Read
var emp = context.Employees.First(e =&gt; e.Id == 1);

// 2️⃣ Modify
emp.Department = "HR";

// 3️⃣ Save
context.SaveChanges(); 
// EF detects change, generates UPDATE SQL, commits transaction
</code></pre>
            <p>Generated SQL:</p>
<pre><code class="language-sql">UPDATE [Employees] SET [Department] = p0 WHERE [Id] = p1;
</code></pre>
            <hr />
            <hr />
            <h1>⚙️ <strong>Caching Query Plans in EF Core</strong></h1>
            <hr />
            <h2>🧠 Why Query Plan Caching?</h2>
            <p>Every time EF Core executes a LINQ query, it must:</p>
            <ol>
                <li>
                    <p><strong>Parse</strong> the expression tree.</p>
                </li>
                <li>
                    <p><strong>Translate</strong> it into SQL.</p>
                </li>
                <li>
                    <p><strong>Generate a query plan</strong> (how the database should execute it).</p>
                </li>
            </ol>
            <p>➡️ This process can be <strong>expensive</strong> if the same query is executed repeatedly &mdash; for example, in high-traffic APIs.</p>
            <p>By <strong>caching the query plan</strong>, you skip steps (1) and (2), saving CPU cycles and boosting performance.</p>
            <hr />
            <h1>🧩 1️⃣ EF Core Compiled Queries (Recommended Method)</h1>
            <p>EF Core provides <strong>Compiled Queries</strong> &mdash; a built-in way to cache query plans for <strong>reusable</strong> LINQ queries.</p>
            <p>✅ Once compiled, EF Core <strong>reuses</strong> the same SQL and execution plan each time.</p>
            <hr />
            <h3>🧱 Example &mdash; Without Caching</h3>
<pre><code class="language-csharp">var employee = context.Employees
    .Where(e =&gt; e.Department == "IT")
    .ToList();
</code></pre>
            <p>➡️ EF Core compiles this LINQ &rarr; SQL every time it runs.</p>
            <hr />
            <h3>⚡ Example &mdash; With Compiled Query</h3>
<pre><code class="language-csharp">using Microsoft.EntityFrameworkCore;

private static readonly Func&lt;AppDbContext, string, IEnumerable&lt;Employee&gt;&gt; _getEmployeesByDept =
    EF.CompileQuery((AppDbContext context, string dept) =&gt;
        context.Employees.Where(e =&gt; e.Department == dept));
</code></pre>
            <p>Then call it like:</p>
<pre><code class="language-csharp">var employees = _getEmployeesByDept(context, "IT").ToList();
</code></pre>
            <p>✅ Now EF Core <strong>compiles this once</strong>, caches it in memory, and <strong>reuses</strong> the plan each time you call <code>_getEmployeesByDept</code>.</p>
            <hr />
            <h2>🧭 2️⃣ When to Use Compiled Queries</h2>
            <p>Use compiled queries when:</p>
            <ul>
                <li>
                    <p>The same query is executed <strong>many times</strong>.</p>
                </li>
                <li>
                    <p>The query is <strong>parameterized</strong> (like searching by name or department).</p>
                </li>
                <li>
                    <p>You need <strong>low latency</strong> for read-heavy APIs.</p>
                </li>
            </ul>
            <p>Avoid for:</p>
            <ul>
                <li>
                    <p>Highly dynamic queries (different structure each time).</p>
                </li>
                <li>
                    <p>Small apps where query translation overhead is minimal.</p>
                </li>
            </ul>
            <hr />
            <h2>🧱 3️⃣ Example &mdash; Query with Multiple Parameters</h2>
<pre><code class="language-csharp">private static readonly Func&lt;AppDbContext, string, int, IEnumerable&lt;Employee&gt;&gt; _getEmployeesByDeptAndAge =
    EF.CompileQuery((AppDbContext context, string dept, int age) =&gt;
        context.Employees.Where(e =&gt; e.Department == dept &amp;&amp; e.Age &gt; age));
</code></pre>
            <p>Usage:</p>
<pre><code class="language-csharp">var result = _getEmployeesByDeptAndAge(context, "IT", 25).ToList();
</code></pre>
            <p>✅ The query is <strong>compiled once</strong>, reused for all parameter values.</p>
            <hr />
            <h2>⚙️ 4️⃣ Compiled Async Queries</h2>
            <p>For async performance:</p>
<pre><code class="language-csharp">private static readonly Func&lt;AppDbContext, string, IAsyncEnumerable&lt;Employee&gt;&gt; _getEmployeesAsync =
    EF.CompileAsyncQuery((AppDbContext context, string dept) =&gt;
        context.Employees.Where(e =&gt; e.Department == dept));
</code></pre>
            <p>Usage:</p>
<pre><code class="language-csharp">await foreach (var e in _getEmployeesAsync(context, "Finance"))
{
    Console.WriteLine(e.Name);
}
</code></pre>
            <hr />
            <h2>🧰 5️⃣ Behind the Scenes</h2>
            <h3>EF Core does this under the hood:</h3>
            <ol>
                <li>
                    <p>Parses your LINQ &rarr; Expression Tree.</p>
                </li>
                <li>
                    <p>Translates it &rarr; SQL (once).</p>
                </li>
                <li>
                    <p>Saves the translation in an <strong>internal cache dictionary</strong>.</p>
                </li>
                <li>
                    <p>Next time: skips parsing, uses the cached SQL plan.</p>
                </li>
            </ol>
            <p>This is <strong>per AppDomain / process</strong>, so it&rsquo;s shared across requests (as long as your app runs).</p>
            <hr />
            <h2>🚀 6️⃣ Performance Comparison</h2>
            <table>
                <thead>
                    <tr>
                        <th>Type</th>
                        <th>Translation Cost</th>
                        <th>Ideal Use Case</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Normal LINQ Query</td>
                        <td>Compiled every time</td>
                        <td>Simple apps</td>
                    </tr>
                    <tr>
                        <td>Compiled Query</td>
                        <td>Compiled once, reused</td>
                        <td>High-traffic read APIs</td>
                    </tr>
                    <tr>
                        <td>Raw SQL Query</td>
                        <td>You control SQL</td>
                        <td>Complex joins, legacy DB</td>
                    </tr>
                </tbody>
            </table>
            <p>Performance gain: <strong>10&ndash;30%</strong> faster in repeated-query scenarios.</p>
            <hr />
            <h2>🧩 7️⃣ Advanced Pattern &mdash; Caching Results (App-Level Cache)</h2>
            <p>Compiled queries cache <strong>query plans</strong>, not <strong>data</strong>.<br /> If you want to <strong>cache data results</strong>, use:</p>
<pre><code class="language-csharp">// Example: Memory Cache + EF Core
var cacheKey = $"Employees_{dept}";
if (!_cache.TryGetValue(cacheKey, out List&lt;Employee&gt; employees))
{
    employees = _getEmployeesByDept(context, dept).ToList();

    _cache.Set(cacheKey, employees, TimeSpan.FromMinutes(10));
}
</code></pre>
            <p>✅ Use <code>IMemoryCache</code> or <code>IDistributedCache</code> (e.g., Redis) for result caching.</p>
            <hr />
            <h2>🧾 8️⃣ Summary Table</h2>
            <table>
                <thead>
                    <tr>
                        <th>Feature</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>EF.CompileQuery</strong></td>
                        <td>Compiles LINQ query once and caches plan</td>
                    </tr>
                    <tr>
                        <td><strong>EF.CompileAsyncQuery</strong></td>
                        <td>Async version for high-concurrency apps</td>
                    </tr>
                    <tr>
                        <td><strong>Use Case</strong></td>
                        <td>Repeated queries with same structure</td>
                    </tr>
                    <tr>
                        <td><strong>Benefit</strong></td>
                        <td>Reduces CPU and improves query latency</td>
                    </tr>
                    <tr>
                        <td><strong>Limitations</strong></td>
                        <td>Not suitable for dynamic queries</td>
                    </tr>
                    <tr>
                        <td><strong>Result Caching</strong></td>
                        <td>Use MemoryCache or Redis (separate concept)</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>⚡ Real-World Tip</h2>
            <p>In <strong>high-traffic Web APIs</strong> (e.g., searching products or users), define a set of <strong>compiled queries</strong> for your most common LINQ filters.<br /> Combine with <strong>AsNoTracking()</strong> for read-only performance.</p>
            <hr />
            <p>✅ <strong>Example Combo for Max Speed:</strong></p>
<pre><code class="language-csharp">private static readonly Func&lt;AppDbContext, string, IEnumerable&lt;Employee&gt;&gt; _getByDept =
    EF.CompileQuery((AppDbContext context, string dept) =&gt;
        context.Employees.AsNoTracking().Where(e =&gt; e.Department == dept));
</code></pre>
            <p>This gives you:</p>
            <ul>
                <li>
                    <p>No tracking overhead</p>
                </li>
                <li>
                    <p>Cached query plan</p>
                </li>
                <li>
                    <p>Fast parameterized execution</p>
                </li>
            </ul>
            <hr />
            <h1>⚙️ <strong>Entity Loading in EF Core</strong></h1>
            <hr />
            <h2>🧠 <strong>What Problem Are We Solving?</strong></h2>
            <p>When you query an entity that has <strong>related data</strong>, EF Core must decide <em>how and when</em> to load those relationships.</p>
            <p>Example:</p>
<pre><code class="language-csharp">var employees = context.Employees.ToList();
</code></pre>
            <p>Each <code>Employee</code> may belong to a <code>Department</code>.</p>
            <p>So EF Core must answer:</p>
            <blockquote>
                <p>&ldquo;Should I also load the <code>Department</code> table data now or later?&rdquo;</p>
            </blockquote>
            <p>That&rsquo;s where <strong>Eager</strong>, <strong>Lazy</strong>, and <strong>Explicit Loading</strong> come in.</p>
            <hr />
            <h1>🧩 <strong>1️⃣ EAGER LOADING</strong></h1>
            <h3>🔹 Definition</h3>
            <p>EF Core loads the <strong>main entity and related data together in a single query</strong> (using <code>Include()</code>).</p>
            <p>✅ Good for:</p>
            <ul>
                <li>
                    <p>When you <strong>know</strong> you&rsquo;ll need related data.</p>
                </li>
                <li>
                    <p>Avoiding <strong>multiple round-trips</strong> to the database.</p>
                </li>
            </ul>
            <hr />
            <h3>🔸 Example</h3>
<pre><code class="language-csharp">var employees = context.Employees
    .Include(e =&gt; e.Department)
    .ToList();
</code></pre>
            <h3>🧱 SQL Generated</h3>
<pre><code class="language-sql">SELECT e.Id, e.Name, e.DepartmentId, d.Id, d.Name
FROM Employees AS e
INNER JOIN Departments AS d ON e.DepartmentId = d.Id;
</code></pre>
            <p>✅ <strong>Pros</strong></p>
            <ul>
                <li>
                    <p>Single database query</p>
                </li>
                <li>
                    <p>Simple and predictable</p>
                </li>
                <li>
                    <p>Best for bulk data retrieval</p>
                </li>
            </ul>
            <p>❌ <strong>Cons</strong></p>
            <ul>
                <li>
                    <p>May fetch <strong>more data</strong> than needed</p>
                </li>
                <li>
                    <p>Can cause <strong>performance overhead</strong> with large joins</p>
                </li>
            </ul>
            <hr />
            <h3>⚡ Example with Multiple Includes</h3>
<pre><code class="language-csharp">var employees = context.Employees
    .Include(e =&gt; e.Department)
    .Include(e =&gt; e.Projects)
    .ToList();
</code></pre>
            <p>EF Core automatically loads <strong>nested relationships</strong> too:</p>
<pre><code class="language-csharp">.Include(e =&gt; e.Department.Manager)
</code></pre>
            <hr />
            <h3>🔎 <strong>When to Use Eager Loading</strong></h3>
            <ul>
                <li>
                    <p>REST APIs returning DTOs with full related info</p>
                </li>
                <li>
                    <p>Reports or dashboards (where all data is needed)</p>
                </li>
                <li>
                    <p>Avoiding <strong>N+1 query problem</strong> (too many small queries)</p>
                </li>
            </ul>
            <hr />
            <h1>🧩 <strong>2️⃣ LAZY LOADING</strong></h1>
            <h3>🔹 Definition</h3>
            <p>EF Core loads <strong>related data on demand</strong>, only when you access the navigation property &mdash; <em>after</em> the main entity is loaded.</p>
            <p>✅ Good for:</p>
            <ul>
                <li>
                    <p>Scenarios where related data <em>might not be needed</em></p>
                </li>
                <li>
                    <p>Simplifying navigation logic in object graphs</p>
                </li>
            </ul>
            <hr />
            <h3>🔧 Setup Requirements</h3>
            <p>Lazy loading is <strong>not enabled by default</strong>.<br /> You need to install and configure it manually:</p>
<pre><code class="language-bash">dotnet add package Microsoft.EntityFrameworkCore.Proxies
</code></pre>
            <p>Then, enable in your DbContext:</p>
<pre><code class="language-csharp">protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    optionsBuilder
        .UseLazyLoadingProxies()
        .UseSqlServer("connection_string");
}
</code></pre>
            <p>And make navigation properties <strong>virtual</strong>:</p>
<pre><code class="language-csharp">public class Employee
{
    public int Id { get; set; }
    public string Name { get; set; }

    public int DepartmentId { get; set; }
    public virtual Department Department { get; set; }  // virtual enables proxy
}
</code></pre>
            <hr />
            <h3>🔸 Example</h3>
<pre><code class="language-csharp">var employees = context.Employees.ToList();

// EF only fetched Employees at first
// Accessing the navigation triggers a new query

foreach (var e in employees)
{
    Console.WriteLine(e.Department.Name); // triggers separate SQL per access
}
</code></pre>
            <h3>🧱 SQL Generated</h3>
            <p>1️⃣ For Employees:</p>
<pre><code class="language-sql">SELECT * FROM Employees;
</code></pre>
            <p>2️⃣ For each Department:</p>
<pre><code class="language-sql">SELECT * FROM Departments WHERE Id = p0;
</code></pre>
            <p>This is called the <strong>N+1 Query Problem</strong> 😬</p>
            <hr />
            <h3>✅ <strong>Pros</strong></h3>
            <ul>
                <li>
                    <p>Loads only what&rsquo;s actually used</p>
                </li>
                <li>
                    <p>Cleaner code for deep navigation</p>
                </li>
            </ul>
            <h3>❌ <strong>Cons</strong></h3>
            <ul>
                <li>
                    <p>Many small database hits (performance issue)</p>
                </li>
                <li>
                    <p>Harder to debug queries</p>
                </li>
                <li>
                    <p>Not supported in all architectures (e.g., disconnected contexts like Web APIs)</p>
                </li>
            </ul>
            <hr />
            <h3>🔎 <strong>When to Use Lazy Loading</strong></h3>
            <ul>
                <li>
                    <p>Desktop or WPF apps (connected DbContext)</p>
                </li>
                <li>
                    <p>Prototypes / quick development scenarios</p>
                </li>
                <li>
                    <p>Small datasets or rarely accessed relationships</p>
                </li>
            </ul>
            <hr />
            <h1>🧩 <strong>3️⃣ EXPLICIT LOADING</strong></h1>
            <h3>🔹 Definition</h3>
            <p>You manually control when to load related data <strong>after the main entity is loaded</strong>, using the <code>Entry()</code> API.</p>
            <p>✅ Good for:</p>
            <ul>
                <li>
                    <p><strong>Fine-grained control</strong></p>
                </li>
                <li>
                    <p><strong>Partial data loading</strong> (only when certain conditions are met)</p>
                </li>
                <li>
                    <p>Avoiding Lazy Loading overhead while staying flexible</p>
                </li>
            </ul>
            <hr />
            <h3>🔸 Example</h3>
<pre><code class="language-csharp">var employee = context.Employees.First(e =&gt; e.Id == 1);

// Manually load related entity
context.Entry(employee)
    .Reference(e =&gt; e.Department)
    .Load();
</code></pre>
            <p>If it&rsquo;s a collection:</p>
<pre><code class="language-csharp">context.Entry(employee)
    .Collection(e =&gt; e.Projects)
    .Load();
</code></pre>
            <hr />
            <h3>🧱 SQL Generated</h3>
<pre><code class="language-sql">SELECT * FROM Employees WHERE Id = 1;

SELECT * FROM Departments WHERE Id = p0;
</code></pre>
            <p>✅ You decide <em>when</em> to run the second query.</p>
            <hr />
            <h3>⚡ Conditional Explicit Loading</h3>
            <p>Load only if not already loaded:</p>
<pre><code class="language-csharp">var entry = context.Entry(employee);

if (!entry.Reference(e =&gt; e.Department).IsLoaded)
{
    entry.Reference(e =&gt; e.Department).Load();
}
</code></pre>
            <hr />
            <h3>✅ <strong>Pros</strong></h3>
            <ul>
                <li>
                    <p>Full control over what to load</p>
                </li>
                <li>
                    <p>Avoids unnecessary joins</p>
                </li>
                <li>
                    <p>No need for proxies (like Lazy Loading)</p>
                </li>
            </ul>
            <h3>❌ <strong>Cons</strong></h3>
            <ul>
                <li>
                    <p>More code to manage</p>
                </li>
                <li>
                    <p>Multiple round-trips if not careful</p>
                </li>
            </ul>
            <hr />
            <h1>🧭 <strong>4️⃣ Comparison Summary</strong></h1>
            <table>
                <thead>
                    <tr>
                        <th>Feature</th>
                        <th>Eager Loading</th>
                        <th>Lazy Loading</th>
                        <th>Explicit Loading</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Definition</strong></td>
                        <td>Loads all data upfront</td>
                        <td>Loads related data when accessed</td>
                        <td>Loads related data manually</td>
                    </tr>
                    <tr>
                        <td><strong>How</strong></td>
                        <td><code>Include()</code></td>
                        <td><code>virtual</code> navigation + proxy</td>
                        <td><code>context.Entry(...).Load()</code></td>
                    </tr>
                    <tr>
                        <td><strong># of Queries</strong></td>
                        <td>1</td>
                        <td>Many (N+1)</td>
                        <td>Controlled</td>
                    </tr>
                    <tr>
                        <td><strong>Performance</strong></td>
                        <td>Great for known data needs</td>
                        <td>Can degrade with large data</td>
                        <td>Good (you control timing)</td>
                    </tr>
                    <tr>
                        <td><strong>Configuration Needed</strong></td>
                        <td>None</td>
                        <td>Must enable proxies</td>
                        <td>None</td>
                    </tr>
                    <tr>
                        <td><strong>Best For</strong></td>
                        <td>APIs, Reports</td>
                        <td>Desktop apps</td>
                        <td>Selective loading</td>
                    </tr>
                    <tr>
                        <td><strong>Example Use</strong></td>
                        <td><code>.Include(e =&gt; e.Department)</code></td>
                        <td><code>e.Department.Name</code> (auto-load)</td>
                        <td><code>context.Entry(e).Reference(...).Load()</code></td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h1>⚙️ <strong>5️⃣ Real-World Scenarios</strong></h1>
            <table>
                <thead>
                    <tr>
                        <th>Scenario</th>
                        <th>Recommended Loading</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Web API returning full object graph</td>
                        <td><strong>Eager</strong></td>
                    </tr>
                    <tr>
                        <td>Small desktop app, accessing data interactively</td>
                        <td><strong>Lazy</strong></td>
                    </tr>
                    <tr>
                        <td>Complex domain logic (load relationships conditionally)</td>
                        <td><strong>Explicit</strong></td>
                    </tr>
                    <tr>
                        <td>Read-heavy query with known relationships</td>
                        <td><strong>Eager + AsNoTracking()</strong></td>
                    </tr>
                    <tr>
                        <td>High-performance microservice (avoid extra round-trips)</td>
                        <td><strong>Eager</strong></td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h1>🧠 <strong>6️⃣ Best Practice Summary</strong></h1>
            <p>✅ <strong>Eager Loading</strong></p>
            <ul>
                <li>
                    <p>Default choice for APIs</p>
                </li>
                <li>
                    <p>Prevents N+1 issues</p>
                </li>
                <li>
                    <p>Use <code>.Include()</code> for predictable performance</p>
                </li>
            </ul>
            <p>✅ <strong>Lazy Loading</strong></p>
            <ul>
                <li>
                    <p>Only in connected, interactive apps (WPF, WinForms)</p>
                </li>
                <li>
                    <p>Avoid in stateless (ASP.NET) apps</p>
                </li>
            </ul>
            <p>✅ <strong>Explicit Loading</strong></p>
            <ul>
                <li>
                    <p>When you want precise control (audit systems, large datasets)</p>
                </li>
            </ul>
            <hr />
            <h1>🧩 <strong>7️⃣ Example Comparison Summary (All 3)</strong></h1>
<pre><code class="language-csharp">// EAGER
var emp1 = context.Employees.Include(e =&gt; e.Department).First();

// LAZY (Requires virtual + proxy)
var emp2 = context.Employees.First();
var dept = emp2.Department; // triggers SQL when accessed

// EXPLICIT
var emp3 = context.Employees.First();
context.Entry(emp3).Reference(e =&gt; e.Department).Load();
</code></pre>
            <hr />
            <h1>⚡ <strong>Bonus Tip &mdash; Combining with AsNoTracking()</strong></h1>
            <p>For read-only data:</p>
<pre><code class="language-csharp">var employees = context.Employees
    .Include(e =&gt; e.Department)
    .AsNoTracking()
    .ToList();
</code></pre>
            <p>✅ Best performance for APIs or reports<br /> ✅ Skips tracking and change detection overhead</p>
            <hr />
        </div>
    </TabPage>
    <TabPage Title="API Performance">
        <div class="content">
            <h1>🚀 <strong>API Performance &amp; Scalability &mdash; Complete Guide (.NET Core)</strong></h1>
            <hr />
            <h2>🧠 1️⃣ Understanding Performance vs Scalability</h2>
            <table>
                <thead>
                    <tr>
                        <th>Term</th>
                        <th>Meaning</th>
                        <th>Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Performance</strong></td>
                        <td>How fast a single request is processed</td>
                        <td>Reducing request latency from 500ms &rarr; 100ms</td>
                    </tr>
                    <tr>
                        <td><strong>Scalability</strong></td>
                        <td>How many requests can be handled efficiently as load increases</td>
                        <td>Serving 100 &rarr; 10,000 requests/sec without crashing</td>
                    </tr>
                </tbody>
            </table>
            <p>✅ A performant API responds quickly.<br /> ✅ A scalable API maintains performance as traffic grows.</p>
            <hr />
            <h2>⚙️ 2️⃣ Performance Fundamentals</h2>
            <p>Let&rsquo;s start with the basics &mdash; what makes an API <em>fast</em>.</p>
            <hr />
            <h3>🔹 a) Use Asynchronous Programming</h3>
            <p>Use <strong>async/await</strong> for I/O-bound work (like DB or HTTP calls).</p>
<pre><code class="language-csharp">[HttpGet("{id}")]
public async Task&lt;IActionResult&gt; GetUser(int id)
{
    var user = await _userService.GetByIdAsync(id); // async EF query
    return Ok(user);
}
</code></pre>
            <p>✅ Frees up threads &rarr; handles more concurrent requests.<br /> ❌ Avoid <code>Task.Result</code> or <code>.Wait()</code> &mdash; it blocks the thread.</p>
            <hr />
            <h3>🔹 b) Minimize Database Round-Trips</h3>
            <p>Each database call adds latency.</p>
            <p><strong>Better:</strong> batch queries, use projections, or joins.</p>
<pre><code class="language-csharp">// ❌ Bad: multiple queries
var user = context.Users.First(u =&gt; u.Id == id);
var posts = context.Posts.Where(p =&gt; p.UserId == id).ToList();

// ✅ Good: single query with Include
var user = context.Users
    .Include(u =&gt; u.Posts)
    .First(u =&gt; u.Id == id);
</code></pre>
            <hr />
            <h3>🔹 c) Use No-Tracking for Read Queries</h3>
<pre><code class="language-csharp">var users = context.Users.AsNoTracking().ToList();
</code></pre>
            <p>✅ Skips EF&rsquo;s change tracker &rarr; 20&ndash;40% faster.</p>
            <hr />
            <h3>🔹 d) Use Pagination (Avoid Loading All Data)</h3>
            <p>Instead of:</p>
<pre><code class="language-csharp">var users = context.Users.ToList();
</code></pre>
            <p>Use:</p>
<pre><code class="language-csharp">var users = context.Users
    .Skip((page - 1) * pageSize)
    .Take(pageSize)
    .AsNoTracking()
    .ToList();
</code></pre>
            <p>✅ Prevents memory overload.<br /> ✅ Scales well with large data.</p>
            <hr />
            <h3>🔹 e) Use Response Caching</h3>
            <p>Use <code>[ResponseCache]</code> or middleware for caching static responses.</p>
<pre><code class="language-csharp">[ResponseCache(Duration = 60)]
[HttpGet("info")]
public IActionResult GetInfo() =&gt; Ok("App Info");
</code></pre>
            <p>✅ Avoids unnecessary recomputation.</p>
            <hr />
            <h3>🔹 f) Optimize JSON Serialization</h3>
            <p>Use <strong>System.Text.Json</strong> (built-in, faster than Newtonsoft.Json).</p>
<pre><code class="language-csharp">builder.Services.AddControllers()
    .AddJsonOptions(opts =&gt;
        opts.JsonSerializerOptions.PropertyNamingPolicy = null);
</code></pre>
            <p>✅ Use <code>JsonIgnore</code> for unnecessary fields.<br /> ✅ Prefer DTOs (lightweight response objects).</p>
            <hr />
            <h2>⚡ 3️⃣ Middleware &amp; Pipeline Optimization</h2>
            <hr />
            <h3>🔹 a) Minimize Middleware</h3>
            <p>Every middleware adds latency.<br /> Keep only essential ones (e.g., Auth, Logging, Exception Handling).</p>
            <p>Example Startup order (best practice):</p>
<pre><code class="language-csharp">app.UseRouting();
app.UseCors();
app.UseAuthentication();
app.UseAuthorization();
app.UseResponseCompression();
app.MapControllers();
</code></pre>
            <p>✅ Order matters &mdash; keep <code>UseRouting()</code> before auth middlewares.</p>
            <hr />
            <h3>🔹 b) Response Compression</h3>
            <p>Enable GZIP or Brotli compression to reduce response size.</p>
<pre><code class="language-csharp">builder.Services.AddResponseCompression();

app.UseResponseCompression();
</code></pre>
            <p>✅ Especially effective for JSON responses and large payloads.</p>
            <hr />
            <h3>🔹 c) Enable HTTP/2 and Keep-Alive</h3>
            <ul>
                <li>
                    <p>HTTP/2 supports multiplexing &mdash; multiple requests per connection.</p>
                </li>
                <li>
                    <p>Keep connections open for reuse.</p>
                </li>
            </ul>
            <p>Configure in <code>appsettings.json</code> or Kestrel options.</p>
            <hr />
            <h2>🧰 4️⃣ Caching Strategies</h2>
            <p>Caching reduces redundant computation or DB hits.</p>
            <hr />
            <h3>🔹 a) In-Memory Cache (Per Instance)</h3>
<pre><code class="language-csharp">builder.Services.AddMemoryCache();

public class UserService
{
    private readonly IMemoryCache _cache;
    public UserService(IMemoryCache cache) =&gt; _cache = cache;

    public async Task&lt;User&gt; GetUserAsync(int id)
    {
        return await _cache.GetOrCreateAsync($"user_{id}", async entry =&gt;
        {
            entry.AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(5);
            return await _context.Users.FindAsync(id);
        });
    }
}
</code></pre>
            <p>✅ Simple, fast.<br /> ❌ Not shared across servers.</p>
            <hr />
            <h3>🔹 b) Distributed Cache (Shared Between Servers)</h3>
            <p>Use <strong>Redis</strong> for clustered caching.</p>
<pre><code class="language-csharp">builder.Services.AddStackExchangeRedisCache(options =&gt;
{
    options.Configuration = "localhost:6379";
});
</code></pre>
            <p>✅ Scales horizontally<br /> ✅ Perfect for cloud environments</p>
            <hr />
            <h3>🔹 c) Output Caching (.NET 8+)</h3>
            <p>New in .NET 8 &mdash; caches <strong>entire HTTP responses</strong> automatically.</p>
<pre><code class="language-csharp">builder.Services.AddOutputCache();

app.UseOutputCache();

app.MapGet("/users", async (AppDbContext db) =&gt;
    await db.Users.ToListAsync())
    .CacheOutput();
</code></pre>
            <p>✅ Zero-code caching<br /> ✅ Works with query parameters, headers, and routes</p>
            <hr />
            <h2>🧮 5️⃣ Data Layer Optimization</h2>
            <hr />
            <h3>🔹 a) Compiled Queries</h3>
            <p>Reuse LINQ query plans for repeated queries.</p>
<pre><code class="language-csharp">private static readonly Func&lt;AppDbContext, int, User&gt; _getUser =
    EF.CompileQuery((AppDbContext ctx, int id) =&gt;
        ctx.Users.First(u =&gt; u.Id == id));
</code></pre>
            <p>✅ Avoids query re-compilation overhead.</p>
            <hr />
            <h3>🔹 b) Connection Pooling</h3>
            <p>Enabled by default in EF Core.<br /> Avoid opening/closing connections too frequently &mdash; use dependency-injected <code>DbContext</code>.</p>
            <hr />
            <h3>🔹 c) Indexing and Query Tuning</h3>
            <p>Use database indexes wisely:</p>
            <ul>
                <li>
                    <p>Index frequently filtered columns</p>
                </li>
                <li>
                    <p>Avoid SELECT *</p>
                </li>
            </ul>
            <p>Check SQL queries via:</p>
<pre><code class="language-csharp">context.Database.Log = Console.WriteLine; // or EF logs
</code></pre>
            <hr />
            <h2>🧩 6️⃣ Scalability Techniques</h2>
            <p>Now that performance is solid, let&rsquo;s make it <strong>scalable</strong>.</p>
            <hr />
            <h3>🔹 a) Horizontal Scaling</h3>
            <p>Run multiple instances behind a load balancer (NGINX, Azure Front Door, AWS ELB).</p>
            <p>✅ More instances &rarr; more throughput<br /> ❌ Requires <strong>stateless API</strong> design (no in-memory sessions)</p>
            <hr />
            <h3>🔹 b) Use Asynchronous I/O Everywhere</h3>
            <p>Async = more concurrent requests with fewer threads.<br /> ASP.NET Core&rsquo;s <strong>Kestrel</strong> scales exceptionally well with async code.</p>
            <hr />
            <h3>🔹 c) Background Processing</h3>
            <p>Offload heavy work from HTTP requests.</p>
            <p>Use <strong>BackgroundService</strong> or <strong>Hangfire</strong> for background tasks.</p>
<pre><code class="language-csharp">public class EmailBackgroundService : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken token)
    {
        while (!token.IsCancellationRequested)
        {
            await _emailQueue.ProcessAsync();
            await Task.Delay(1000);
        }
    }
}
</code></pre>
            <p>✅ Keeps API responsive<br /> ✅ Scales async jobs independently</p>
            <hr />
            <h3>🔹 d) Rate Limiting &amp; Throttling</h3>
            <p>Protect against overload using .NET 7+ built-in middleware:</p>
<pre><code class="language-csharp">builder.Services.AddRateLimiter(options =&gt;
{
    options.AddFixedWindowLimiter("fixed", c =&gt;
    {
        c.PermitLimit = 10;
        c.Window = TimeSpan.FromSeconds(10);
    });
});

app.UseRateLimiter();
</code></pre>
            <p>✅ Prevents abuse<br /> ✅ Protects DB and resources</p>
            <hr />
            <h3>🔹 e) Circuit Breakers &amp; Retry Policies</h3>
            <p>Use <strong>Polly</strong> for transient fault handling.</p>
<pre><code class="language-csharp">builder.Services.AddHttpClient("MyAPI")
    .AddPolicyHandler(Policy
        .Handle&lt;HttpRequestException&gt;()
        .CircuitBreakerAsync(5, TimeSpan.FromSeconds(30)));
</code></pre>
            <p>✅ Improves resilience during DB or network downtime.</p>
            <hr />
            <h3>🔹 f) CDN (Content Delivery Network)</h3>
            <p>For static content (images, scripts, etc.) &rarr; serve from a CDN like Azure CDN or CloudFront.</p>
            <p>✅ Offloads API servers<br /> ✅ Global distribution &rarr; low latency</p>
            <hr />
            <h2>🧩 7️⃣ Observability &amp; Monitoring</h2>
            <p>You can&rsquo;t optimize what you can&rsquo;t measure.</p>
            <table>
                <thead>
                    <tr>
                        <th>Tool</th>
                        <th>Purpose</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Application Insights</strong></td>
                        <td>Tracks API response time, exceptions, dependencies</td>
                    </tr>
                    <tr>
                        <td><strong>Prometheus + Grafana</strong></td>
                        <td>Metrics and dashboards</td>
                    </tr>
                    <tr>
                        <td><strong>OpenTelemetry (.NET 8)</strong></td>
                        <td>Distributed tracing</td>
                    </tr>
                    <tr>
                        <td><strong>Serilog / Seq</strong></td>
                        <td>Structured logging for performance analysis</td>
                    </tr>
                </tbody>
            </table>
            <p>✅ Log request latency, DB time, and cache hit rates.</p>
            <hr />
            <h2>⚡ 8️⃣ Quick Performance Checklist</h2>
            <table>
                <thead>
                    <tr>
                        <th>Area</th>
                        <th>Optimization</th>
                        <th>Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Async I/O</td>
                        <td>Use async/await</td>
                        <td><code>await db.Users.ToListAsync()</code></td>
                    </tr>
                    <tr>
                        <td>Caching</td>
                        <td>MemoryCache, Redis, OutputCache</td>
                        <td><code>_cache.GetOrCreateAsync()</code></td>
                    </tr>
                    <tr>
                        <td>DB Access</td>
                        <td>AsNoTracking, pagination, Include</td>
                        <td><code>AsNoTracking().Take(50)</code></td>
                    </tr>
                    <tr>
                        <td>JSON</td>
                        <td>System.Text.Json</td>
                        <td><code>AddJsonOptions()</code></td>
                    </tr>
                    <tr>
                        <td>Middleware</td>
                        <td>Optimize order, minimal</td>
                        <td><code>UseRouting() &rarr; UseAuth() &rarr; MapControllers()</code></td>
                    </tr>
                    <tr>
                        <td>Compression</td>
                        <td>Gzip, Brotli</td>
                        <td><code>AddResponseCompression()</code></td>
                    </tr>
                    <tr>
                        <td>Rate Limiting</td>
                        <td>Built-in middleware</td>
                        <td><code>AddRateLimiter()</code></td>
                    </tr>
                    <tr>
                        <td>Background Jobs</td>
                        <td>Hangfire, QueueWorker</td>
                        <td><code>BackgroundService</code></td>
                    </tr>
                    <tr>
                        <td>Load Balancing</td>
                        <td>Scale horizontally</td>
                        <td>NGINX, Azure App Service</td>
                    </tr>
                    <tr>
                        <td>Monitoring</td>
                        <td>App Insights, Serilog</td>
                        <td>Track latency, throughput</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>🧠 9️⃣ Final Architectural Advice</h2>
            <p><strong>Design APIs to be:</strong></p>
            <ul>
                <li>
                    <p>✅ <strong>Stateless</strong> &mdash; no user-specific in-memory data</p>
                </li>
                <li>
                    <p>✅ <strong>Async-first</strong> &mdash; scale with fewer threads</p>
                </li>
                <li>
                    <p>✅ <strong>Cache-aware</strong> &mdash; use Redis or OutputCache</p>
                </li>
                <li>
                    <p>✅ <strong>Observable</strong> &mdash; log, trace, monitor</p>
                </li>
                <li>
                    <p>✅ <strong>Elastic</strong> &mdash; run multiple instances effortlessly</p>
                </li>
            </ul>
            <hr />
        </div>
    </TabPage>
    <TabPage Title="Garbage Collection">
        <div class="content">
            <h1>🧩 <strong>.NET Garbage Collection &mdash; Visual Flow</strong></h1>
            <hr />
            <h2>🧠 Concept Summary</h2>
            <p>The <strong>CLR (Common Language Runtime)</strong> uses a <strong>Generational Garbage Collector</strong> to manage memory efficiently.<br /> Objects are grouped into <strong>Generations (0, 1, 2)</strong> based on their lifetime.</p>
            <blockquote>
                <p>🧠 <strong>Key Principle:</strong><br /> &ldquo;Most objects die young.&rdquo; &mdash; so Gen 0 is collected <em>most frequently</em>, Gen 2 <em>rarely.</em></p>
            </blockquote>
            <hr />
            <h1>🧭 <strong>Memory Generation Diagram</strong></h1>
<pre><code>┌────────────────────────────────────────────────────────────┐
│                   MANAGED HEAP (in CLR)                    │
└────────────────────────────────────────────────────────────┘

                ┌──────────────────────────┐
                │      Generation 0        │
                │  Short-lived objects     │
                │  (e.g., local strings,   │
                │   temp lists, requests)  │
                └──────────┬───────────────┘
                           │  (if survives)
                           ▼
                ┌──────────────────────────┐
                │      Generation 1        │
                │  Medium-lived objects    │
                │  (cached objects,        │
                │   mid-level services)    │
                └──────────┬───────────────┘
                           │  (if survives again)
                           ▼
                ┌──────────────────────────┐
                │      Generation 2        │
                │  Long-lived objects      │
                │  (e.g., app-wide singletons,  │
                │   static config, logger)     │
                └──────────┬───────────────┘
                           │
                           ▼
                ┌──────────────────────────┐
                │ Large Object Heap (LOH)  │
                │  &gt; 85 KB objects         │
                │  (images, big arrays)    │
                └──────────────────────────┘
</code></pre>
            <hr />
            <h1>⚙️ <strong>Garbage Collection Lifecycle</strong></h1>
<pre><code>1️⃣ Allocation
&darr;
2️⃣ Mark
&darr;
3️⃣ Sweep
&darr;
4️⃣ Compact
&darr;
5️⃣ Promotion (if object survives)
</code></pre>
            <hr />
            <h2>🔁 <strong>Lifecycle Example</strong></h2>
            <p>Let&rsquo;s imagine you&rsquo;re building an ASP.NET Core web API.</p>
            <h3>Step 1️⃣ &mdash; Allocation</h3>
            <p>Every time a request arrives:</p>
<pre><code class="language-csharp">var response = new ResponseModel();
</code></pre>
            <p>👉 Stored in <strong>Generation 0</strong> (short-lived).</p>
            <hr />
            <h3>Step 2️⃣ &mdash; GC Collects Gen 0</h3>
            <p>After a few requests, the <strong>Gen 0 heap</strong> fills up.<br /> GC runs:</p>
            <ul>
                <li>
                    <p>Scans for live references.</p>
                </li>
                <li>
                    <p>Removes unreachable objects.</p>
                </li>
                <li>
                    <p>Moves surviving ones &rarr; <strong>Gen 1</strong>.</p>
                </li>
            </ul>
            <hr />
            <h3>Step 3️⃣ &mdash; Survive Again</h3>
            <p>If your object is still referenced (e.g., caching):</p>
<pre><code class="language-csharp">_cache["user"] = response;
</code></pre>
            <p>It survives multiple collections &rarr; moves to <strong>Gen 2</strong>.</p>
            <hr />
            <h3>Step 4️⃣ &mdash; Long-Lived Objects</h3>
            <p>Now it&rsquo;s treated as a <strong>long-lived</strong> object (like static config, singleton logger).<br /> It&rsquo;s only cleaned when the app shuts down or memory is critically low.</p>
            <hr />
            <h3>Step 5️⃣ &mdash; Large Object Heap (LOH)</h3>
            <p>If you allocate something huge:</p>
<pre><code class="language-csharp">byte[] bigBuffer = new byte[100_000];
</code></pre>
            <p>It&rsquo;s directly stored in <strong>LOH</strong>, which:</p>
            <ul>
                <li>
                    <p>Is <strong>not compacted frequently</strong></p>
                </li>
                <li>
                    <p>Can cause <strong>fragmentation</strong></p>
                </li>
                <li>
                    <p>Should be managed carefully (use object pooling!)</p>
                </li>
            </ul>
            <hr />
            <h1>🔄 <strong>Full GC Process Visualization</strong></h1>
<pre><code>┌────────────────────────────────────────────────────────────┐
│                     Garbage Collection Cycle               │
└────────────────────────────────────────────────────────────┘

[1] Application running &rarr; Allocating objects in Gen 0
         │
         ▼
[2] Gen 0 fills up &rarr; GC collects dead objects
         │
         ▼
[3] Survivors &rarr; promoted to Gen 1
         │
         ▼
[4] More collections &rarr; survivors &rarr; promoted to Gen 2
         │
         ▼
[5] Gen 2 rarely collected &rarr; long-lived objects stay
         │
         ▼
[6] LOH (Large Object Heap) handled separately
</code></pre>
            <hr />
            <h1>⚙️ <strong>Example Code &mdash; Tracking Generations</strong></h1>
<pre><code class="language-csharp">using System;

class Program
{
    static void Main()
    {
        object obj = new object();

        Console.WriteLine(GC.GetGeneration(obj)); // &rarr; 0
        GC.Collect();
        Console.WriteLine(GC.GetGeneration(obj)); // &rarr; 1 or 2 (if survived)

        Console.WriteLine("Total Memory: " + GC.GetTotalMemory(false));
    }
}
</code></pre>
            <hr />
            <h1>💡 <strong>Performance Tips</strong></h1>
            <p>✅ <strong>Best Practices for Managing Memory:</strong></p>
            <table>
                <thead>
                    <tr>
                        <th>Tip</th>
                        <th>Why</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Avoid calling <code>GC.Collect()</code></td>
                        <td>Let CLR decide optimal time</td>
                    </tr>
                    <tr>
                        <td>Dispose unmanaged resources (<code>IDisposable</code>)</td>
                        <td>Prevent leaks</td>
                    </tr>
                    <tr>
                        <td>Use <code>using</code> blocks</td>
                        <td>Ensures cleanup</td>
                    </tr>
                    <tr>
                        <td>Avoid large temporary allocations</td>
                        <td>Prevent LOH fragmentation</td>
                    </tr>
                    <tr>
                        <td>Use <code>ArrayPool&lt;T&gt;</code> or <code>ObjectPool&lt;T&gt;</code></td>
                        <td>Reuse objects</td>
                    </tr>
                    <tr>
                        <td>Remove event subscriptions</td>
                        <td>Avoid memory leaks</td>
                    </tr>
                    <tr>
                        <td>Use memory profiling tools</td>
                        <td>Detect leaks early</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h1>🧰 <strong>Tools to Visualize GC</strong></h1>
            <table>
                <thead>
                    <tr>
                        <th>Tool</th>
                        <th>Usage</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>dotnet-gcdump</strong></td>
                        <td>Collects GC dumps</td>
                    </tr>
                    <tr>
                        <td><strong>Visual Studio Diagnostic Tools</strong></td>
                        <td>Live heap &amp; memory snapshot</td>
                    </tr>
                    <tr>
                        <td><strong>PerfView</strong></td>
                        <td>Deep GC trace</td>
                    </tr>
                    <tr>
                        <td><strong>dotMemory (JetBrains)</strong></td>
                        <td>Leak analysis</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h1>🧾 <strong>Quick Revision Table</strong></h1>
            <table>
                <thead>
                    <tr>
                        <th>Concept</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>GC</strong></td>
                        <td>Automatic cleanup of unused managed objects</td>
                    </tr>
                    <tr>
                        <td><strong>Generations</strong></td>
                        <td>Optimize collection frequency (Gen0, Gen1, Gen2)</td>
                    </tr>
                    <tr>
                        <td><strong>LOH</strong></td>
                        <td>Special heap for large objects (&gt;85KB)</td>
                    </tr>
                    <tr>
                        <td><strong>Promotion</strong></td>
                        <td>Surviving objects move to next generation</td>
                    </tr>
                    <tr>
                        <td><strong>Finalizer</strong></td>
                        <td>Runs before GC reclaims memory</td>
                    </tr>
                    <tr>
                        <td><strong>Dispose</strong></td>
                        <td>Deterministic cleanup for unmanaged resources</td>
                    </tr>
                    <tr>
                        <td><strong>Compact Phase</strong></td>
                        <td>Defragments memory by moving live objects</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h1>🧠 <strong>Interview-Ready One-Line Answers</strong></h1>
            <table>
                <thead>
                    <tr>
                        <th>Question</th>
                        <th>Short Answer</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>What is the purpose of GC?</td>
                        <td>To automatically manage and reclaim memory.</td>
                    </tr>
                    <tr>
                        <td>What are GC generations?</td>
                        <td>0 = short-lived, 1 = medium-lived, 2 = long-lived.</td>
                    </tr>
                    <tr>
                        <td>What&rsquo;s the LOH?</td>
                        <td>Large Object Heap stores objects &gt;85KB.</td>
                    </tr>
                    <tr>
                        <td>When is GC triggered?</td>
                        <td>When Gen0 is full, low memory, or manually forced.</td>
                    </tr>
                    <tr>
                        <td>What is GC.SuppressFinalize()?</td>
                        <td>Prevents finalizer from running unnecessarily.</td>
                    </tr>
                    <tr>
                        <td>What&rsquo;s better &mdash; Finalizer or Dispose?</td>
                        <td>Dispose (deterministic cleanup).</td>
                    </tr>
                </tbody>
            </table>
            <hr />
        </div>
    </TabPage>
    <TabPage Title="Interview">
        <div class="content">
            <h1>💼 Senior .NET Core Developer &mdash; Mock Interview (with Model Answers)</h1>
            <hr />
            <h3>⚙️ <strong>1. Explain .NET Core architecture and how it differs from .NET Framework.</strong></h3>
            <p><strong>Purpose:</strong> Tests understanding of platform evolution, cross-platform design, and runtime internals.</p>
            <p><strong>Answer:</strong></p>
            <blockquote>
                <p>.NET Core is a <strong>modular, cross-platform, open-source</strong> framework. It runs on multiple OSes using the <strong>CoreCLR runtime</strong> and uses <strong>NuGet packages</strong> for modular deployment.<br /> Unlike .NET Framework (Windows-only, monolithic), .NET Core (and modern unified .NET 6/7/8) supports <strong>side-by-side versioning</strong>, <strong>self-contained deployment</strong>, <strong>containerization</strong>, and <strong>high performance</strong> via the <strong>Kestrel</strong> web server.</p>
            </blockquote>
            <p><strong>Example:</strong></p>
            <blockquote>
                <p>&ldquo;We migrated a .NET Framework 4.7 Web API to .NET 6. The result: deployment size decreased by 35%, and we could run Linux containers in Azure Kubernetes Service, which cut hosting costs by 40%.&rdquo;</p>
            </blockquote>
            <hr />
            <h3>🔄 <strong>2. How do you design scalable APIs in ASP.NET Core?</strong></h3>
            <p><strong>Purpose:</strong> Tests architectural maturity, REST best practices, and design tradeoffs.</p>
            <p><strong>Answer:</strong></p>
            <ul>
                <li>
                    <p>Follow <strong>Clean Architecture</strong> &rarr; Controllers &rarr; Services &rarr; Repositories &rarr; Database.</p>
                </li>
                <li>
                    <p>Use <strong>DTOs</strong> for communication, <strong>automapper</strong> for mapping.</p>
                </li>
                <li>
                    <p>Implement <strong>global exception middleware</strong>, <strong>FluentValidation</strong> for model validation.</p>
                </li>
                <li>
                    <p>Use <strong>API versioning</strong>, <strong>JWT auth</strong>, <strong>CORS</strong>, <strong>Swagger/OpenAPI</strong>.</p>
                </li>
                <li>
                    <p>Add <strong>response caching</strong>, <strong>rate limiting</strong>, and <strong>pagination</strong> for performance.</p>
                </li>
            </ul>
            <p><strong>Code Example:</strong></p>
<pre><code class="language-csharp">services.AddApiVersioning(o =&gt;
{
    o.AssumeDefaultVersionWhenUnspecified = true;
    o.DefaultApiVersion = new ApiVersion(1, 0);
});
</code></pre>
            <p><strong>Bonus Tip:</strong> Mention <strong>OpenTelemetry tracing</strong> and <strong>distributed caching (Redis)</strong> for scalability.</p>
            <hr />
            <h3>⚡ <strong>3. What&rsquo;s your approach to improving .NET Core performance under load?</strong></h3>
            <p><strong>Purpose:</strong> Checks ability to diagnose and optimize real systems.</p>
            <p><strong>Answer:</strong></p>
            <blockquote>
                <p>&ldquo;I use profiling tools (dotTrace, PerfView, Application Insights) to identify bottlenecks, then optimize at three levels:&rdquo;</p>
            </blockquote>
            <ol>
                <li>
                    <p><strong>Code:</strong> Avoid unnecessary allocations; use <code>Span&lt;T&gt;</code>, caching, and <code>StringBuilder</code>.</p>
                </li>
                <li>
                    <p><strong>Data:</strong> Use <code>.AsNoTracking()</code> in EF Core; batch queries; reduce N+1.</p>
                </li>
                <li>
                    <p><strong>Architecture:</strong> Introduce async I/O, message queues, and caching.</p>
                </li>
            </ol>
            <p><strong>Example:</strong></p>
            <blockquote>
                <p>&ldquo;We had a 500ms API due to EF Core N+1 queries. Replaced it with a single projection query, reduced response time to 90ms.&rdquo;</p>
            </blockquote>
            <hr />
            <h3>🧠 <strong>4. Describe dependency injection in ASP.NET Core.</strong></h3>
            <p><strong>Purpose:</strong> Assesses understanding of DI lifetimes and pitfalls.</p>
            <p><strong>Answer:</strong></p>
            <blockquote>
                <p>ASP.NET Core has a built-in DI container. Services can be <strong>Transient</strong>, <strong>Scoped</strong>, or <strong>Singleton</strong>.</p>
            </blockquote>
            <table>
                <thead>
                    <tr>
                        <th>Lifetime</th>
                        <th>Description</th>
                        <th>Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Transient</td>
                        <td>New instance every time</td>
                        <td>Lightweight services</td>
                    </tr>
                    <tr>
                        <td>Scoped</td>
                        <td>One per request</td>
                        <td>EF DbContext</td>
                    </tr>
                    <tr>
                        <td>Singleton</td>
                        <td>One for app lifetime</td>
                        <td>Configuration, caching</td>
                    </tr>
                </tbody>
            </table>
            <p><strong>Code:</strong></p>
<pre><code class="language-csharp">services.AddScoped&lt;IUserService, UserService&gt;();
</code></pre>
            <p><strong>Pitfall:</strong><br /> Avoid injecting <code>Scoped</code> into <code>Singleton</code> (causes captured context errors).</p>
            <hr />
            <h3>🧩 <strong>5. How do you handle transactions and concurrency in EF Core?</strong></h3>
            <p><strong>Purpose:</strong> Tests data integrity and transaction understanding.</p>
            <p><strong>Answer:</strong></p>
            <ul>
                <li>
                    <p>Use <code>DbContext.Database.BeginTransaction()</code> for multi-step updates.</p>
                </li>
                <li>
                    <p>Use optimistic concurrency (add a <code>RowVersion</code> column).</p>
                </li>
                <li>
                    <p>Use retry policies for transient SQL errors.</p>
                </li>
            </ul>
            <p><strong>Code Example:</strong></p>
<pre><code class="language-csharp">using var transaction = await context.Database.BeginTransactionAsync();
try
{
    context.Users.Add(user);
    await context.SaveChangesAsync();
    await transaction.CommitAsync();
}
catch
{
    await transaction.RollbackAsync();
}
</code></pre>
            <p><strong>Extra:</strong> Mention using <strong>Unit of Work</strong> or <strong>TransactionScope</strong> where multiple contexts are involved.</p>
            <hr />
            <h3>🧱 <strong>6. How do you implement background tasks in .NET Core?</strong></h3>
            <p><strong>Purpose:</strong> Tests knowledge of worker services and hosted services.</p>
            <p><strong>Answer:</strong></p>
            <blockquote>
                <p>Use <code>IHostedService</code> or <code>BackgroundService</code> for recurring tasks like cleanup, message polling, or scheduled jobs.</p>
            </blockquote>
            <p><strong>Example:</strong></p>
<pre><code class="language-csharp">public class EmailWorker : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            await _emailService.SendPendingEmails();
            await Task.Delay(TimeSpan.FromMinutes(5));
        }
    }
}
</code></pre>
            <p><strong>Tip:</strong> For production jobs, mention <strong>Quartz.NET</strong>, <strong>Hangfire</strong>, or <strong>Azure Functions</strong>.</p>
            <hr />
            <h3>🔐 <strong>7. How do you secure an ASP.NET Core API?</strong></h3>
            <p><strong>Purpose:</strong> Tests authentication, authorization, and security mindset.</p>
            <p><strong>Answer:</strong></p>
            <ul>
                <li>
                    <p>Use <strong>JWT tokens</strong> (stateless, scalable).</p>
                </li>
                <li>
                    <p>Use <strong>ASP.NET Core Identity</strong> for user management if needed.</p>
                </li>
                <li>
                    <p>Secure sensitive data with <strong>Azure Key Vault</strong> or <strong>User Secrets</strong>.</p>
                </li>
                <li>
                    <p>Use <strong>HTTPS</strong>, <strong>CORS policies</strong>, <strong>rate limiting</strong>, and <strong>input validation</strong>.</p>
                </li>
                <li>
                    <p>Log and monitor suspicious requests.</p>
                </li>
            </ul>
            <p><strong>Code Example:</strong></p>
<pre><code class="language-csharp">services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =&gt; { options.TokenValidationParameters = ...; });
</code></pre>
            <hr />
            <h3>🧩 <strong>8. Describe a time you solved a production issue in a distributed .NET system.</strong></h3>
            <p><strong>Purpose:</strong> Tests troubleshooting and experience.</p>
            <p><strong>Answer (STAR format):</strong></p>
            <blockquote>
                <p><strong>Situation:</strong> Our production API started timing out randomly.<br /> <strong>Task:</strong> Identify root cause and fix.<br /> <strong>Action:</strong> Used Application Insights + correlation IDs to trace requests; found thread pool starvation caused by synchronous <code>.Result</code> calls inside async controllers.<br /> <strong>Result:</strong> Refactored to async/await end-to-end. Average response time dropped from 3s &rarr; 400ms.</p>
            </blockquote>
            <hr />
            <h3>🧮 <strong>9. How do you test your .NET Core applications?</strong></h3>
            <p><strong>Purpose:</strong> Evaluates testing culture.</p>
            <p><strong>Answer:</strong></p>
            <ul>
                <li>
                    <p><strong>Unit tests:</strong> Use xUnit/NUnit + Moq for isolated business logic.</p>
                </li>
                <li>
                    <p><strong>Integration tests:</strong> Use <code>WebApplicationFactory&lt;T&gt;</code> to spin up a test server and test endpoints.</p>
                </li>
                <li>
                    <p><strong>End-to-end tests:</strong> Use Postman/Newman or Playwright.</p>
                </li>
                <li>
                    <p><strong>CI/CD:</strong> Integrate with GitHub Actions or Azure DevOps pipelines.</p>
                </li>
            </ul>
            <p><strong>Example:</strong></p>
<pre><code class="language-csharp">public class UserControllerTests : IClassFixture&lt;WebApplicationFactory&lt;Startup&gt;&gt;
{
    private readonly HttpClient _client;
    public UserControllerTests(WebApplicationFactory&lt;Startup&gt; factory)
        =&gt; _client = factory.CreateClient();
}
</code></pre>
            <hr />
            <h3>🧱 <strong>10. How do you design and monitor microservices in .NET Core?</strong></h3>
            <p><strong>Purpose:</strong> Tests architectural vision, scalability, and DevOps alignment.</p>
            <p><strong>Answer:</strong></p>
            <ul>
                <li>
                    <p>Use <strong>Docker</strong> + <strong>Kubernetes</strong> for deployment.</p>
                </li>
                <li>
                    <p>Each service owns its <strong>data</strong>; communicate via REST or <strong>message bus</strong> (RabbitMQ, Azure Service Bus).</p>
                </li>
                <li>
                    <p>Handle distributed transactions with <strong>Sagas</strong> or <strong>event-driven design</strong>.</p>
                </li>
                <li>
                    <p>Use <strong>OpenTelemetry</strong> for distributed tracing and <strong>Prometheus/Grafana</strong> for metrics.</p>
                </li>
                <li>
                    <p>Apply <strong>circuit breakers</strong> and <strong>retries</strong> via <strong>Polly</strong>.</p>
                </li>
            </ul>
            <p><strong>Example:</strong></p>
            <blockquote>
                <p>&ldquo;Our order service publishes <code>OrderCreated</code> events to RabbitMQ; inventory and payment services subscribe. We implemented the saga pattern using MassTransit. OpenTelemetry traces every request from API to DB to message bus.&rdquo;</p>
            </blockquote>
            <hr />
            <h1>💡 Bonus Senior-Level Questions (Quickfire Round)</h1>
            <table>
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Question</th>
                        <th>Short Ideal Answer</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>1</td>
                        <td>What is the difference between synchronous and asynchronous middleware?</td>
                        <td>Async middleware returns a <code>Task</code> and avoids blocking threads, improving scalability.</td>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td>How do you handle configuration in .NET Core?</td>
                        <td>Use appsettings.json + environment-specific overrides + Secret Manager/Azure Key Vault.</td>
                    </tr>
                    <tr>
                        <td>3</td>
                        <td>What is the role of Kestrel in ASP.NET Core?</td>
                        <td>It&rsquo;s the cross-platform web server; can be hosted behind IIS or Nginx as a reverse proxy.</td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td>How do you use caching effectively?</td>
                        <td>Use <code>IMemoryCache</code> for in-memory, <code>IDistributedCache</code> (Redis) for multi-instance scenarios.</td>
                    </tr>
                    <tr>
                        <td>5</td>
                        <td>How do you make APIs idempotent?</td>
                        <td>Use unique request IDs, deduplication, and consistent business logic for retries.</td>
                    </tr>
                </tbody>
            </table>
            <hr />
            <h2>🔍 Senior .NET Core Interview Questions &amp; Model Answers with Examples</h2>
            <hr />
            <h3>1. What are the key differences between .NET Framework, .NET Core, and .NET (5/6/7+)? When and why would you choose one over the others?</h3>
            <p><strong>Answer:</strong></p>
            <ul>
                <li>
                    <p><strong>.NET Framework</strong>: Windows-only, mature libraries, good for legacy enterprise apps, tight integration with Windows. But heavy, not cross-platform.</p>
                </li>
                <li>
                    <p><strong>.NET Core</strong>: Cross-platform (Windows, macOS, Linux), lightweight, modular, better performance. Introduced dependency injection, better tooling, open source.</p>
                </li>
                <li>
                    <p><strong>.NET (5/6/7+)</strong>: Unifies .NET Core + features from Framework; improves performance, adds new APIs (e.g. minimal APIs), long-term support (LTS) versions.</p>
                </li>
            </ul>
            <p><strong>When to choose:</strong></p>
            <ul>
                <li>
                    <p>New projects &rarr; use latest .NET (6/7), unless there is a specific requirement or dependency tying to the .NET Framework.</p>
                </li>
                <li>
                    <p>If you need cross-platform or containers &rarr; .NET Core / .NET.</p>
                </li>
                <li>
                    <p>Legacy maintenance &rarr; may still be on .NET Framework, but evaluate migration cost vs benefit.</p>
                </li>
            </ul>
            <p><strong>Example:</strong></p>
            <blockquote>
                <p>&ldquo;At my last job, we started a greenfield microservice on Azure container infrastructure. We used .NET 6 because of its performance improvements (lower memory, faster startup), and because we expected to deploy on Linux containers. For an old internal reporting desktop app though, migrating to .NET Core wasn&rsquo;t worth the risk at that time.&rdquo;</p>
            </blockquote>
            <hr />
            <h3>2. How do you design a scalable and maintainable RESTful API in ASP.NET Core? What are best practices for versioning, error handling, validation, and security?</h3>
            <p><strong>Answer:</strong></p>
            <ul>
                <li>
                    <p><strong>Separation of concerns / Clean Architecture</strong>: Controllers only coordinate, business logic in services, data access in repos, domain models vs DTOs.</p>
                </li>
                <li>
                    <p><strong>Versioning</strong>: e.g. URL versioning (<code>/api/v1/...</code>), header versioning, or media-type versioning. Maintain backward compatibility; deprecate gracefully.</p>
                </li>
                <li>
                    <p><strong>Validation</strong>: Use model validation attributes, FluentValidation or similar for complex rules; possibly pipeline behavior or middleware. Validate early.</p>
                </li>
                <li>
                    <p><strong>Error handling</strong>: Global exception middleware to catch unhandled exceptions; use standardized error response shape (e.g. ProblemDetails), avoid leaking sensitive info.</p>
                </li>
                <li>
                    <p><strong>Security</strong>: Authentication (JWT, OAuth2), Authorization (role/claims based), input sanitization, rate limiting, CORS setup, ensure sensitive configuration is in secrets / user-secrets / Azure Key Vault. Use HTTPS.</p>
                </li>
                <li>
                    <p><strong>Documentation</strong>: Use Swagger / OpenAPI, include response codes, sample payloads.</p>
                </li>
            </ul>
            <p><strong>Example:</strong></p>
<pre><code class="language-csharp">// Example: configuring API versioning in Startup (or Program in .NET 6+)
services.AddApiVersioning(options =&gt;
{
    options.AssumeDefaultVersionWhenUnspecified = true;
    options.DefaultApiVersion = new ApiVersion(1,0);
    options.ReportApiVersions = true;
});

app.UseExceptionHandler(errorApp =&gt;
{
    errorApp.Run(async context =&gt;
    {
        context.Response.StatusCode = 500;
        context.Response.ContentType = "application/problem+json";
        // generate ProblemDetails
    });
});
</code></pre>
            <hr />
            <h3>3. .NET Core: Async/Await, Concurrency, and Avoiding Pitfalls</h3>
            <p><strong>Question:</strong> How have you used async/await in .NET Core to improve performance? What common pitfalls (deadlocks, thread starvation, over-awaiting) do you look out for, and how do you avoid them?</p>
            <p><strong>Answer:</strong></p>
            <ul>
                <li>
                    <p>Use async/await for I/O bound work (database, network, file I/O), keeping threads free for other work.</p>
                </li>
                <li>
                    <p>Use <code>ConfigureAwait(false)</code> in library code if context doesn&rsquo;t matter, to avoid capturing SynchronizationContext unnecessarily.</p>
                </li>
                <li>
                    <p>Be careful in ASP.NET Core: there is no SynchronizationContext like in older ASP.NET, but still avoid blocking calls (<code>.Result</code>, <code>.Wait</code>) which can cause thread pool starvation.</p>
                </li>
                <li>
                    <p>Use <code>IHostedService</code> or background tasks for long-running work, offload heavy CPU work to separate worker services.</p>
                </li>
                <li>
                    <p>Consider concurrency limits (SemaphoreSlim, bounded channels) when handling many parallel operations to avoid overwhelming resources.</p>
                </li>
            </ul>
            <p><strong>Example:</strong></p>
            <blockquote>
                <p>&ldquo;We had an endpoint that triggered calls to multiple downstream APIs concurrently. Originally it sequentially awaited each call, which led to high latency. We changed to <code>Task.WhenAll(...)</code> to issue them in parallel. Also, to avoid too many concurrent outbound calls, wrapped them in a <code>SemaphoreSlim</code> to allow max-5 parallel calls. Latency dropped by ~40% under load.&rdquo;</p>
            </blockquote>
            <hr />
            <h3>4. EF Core vs Dapper: Trade-offs, performance, usage, and how do you handle migrations and transactions?</h3>
            <p><strong>Answer:</strong></p>
            <ul>
                <li>
                    <p><strong>EF Core</strong>: Oriented for ORMs, ease of use, change tracking, migrations, LINQ querying, relational navigation. Good for domain-driven design, prototyping, when query complexity is moderate.</p>
                </li>
                <li>
                    <p><strong>Dapper</strong>: Micro-ORM, lightweight, fast for raw queries, less overhead. Best for performance-sensitive read queries, reports, bulk operations.</p>
                </li>
                <li>
                    <p><strong>Migrations</strong>: Use EF Core migrations to version schema; ensure migrations are in source control; review generated SQL; possibly generate SQL scripts for production DBs and test; ensure rollback/backup plan.</p>
                </li>
                <li>
                    <p><strong>Transactions</strong>: Use <code>DbContext.Database.BeginTransaction()</code>, or <code>TransactionScope</code> (if needed across multiple contexts). Ensure idempotency if something fails.</p>
                </li>
            </ul>
            <p><strong>Example:</strong></p>
            <blockquote>
                <p>&ldquo;In a project we used EF Core for most CRUD operations because of its productivity. But for reporting queries that joined multiple tables and returned millions of rows, we used Dapper to reduce overhead. For migrations, we generate the SQL and review it before applying to staging, and nightly backup + migration pipeline to avoid surprises.&rdquo;</p>
            </blockquote>
            <hr />
            <h3>5. Performance Optimization: Memory, Response Time, and Throughput</h3>
            <p><strong>Question:</strong> You find your ASP.NET Core service has high memory usage and slow responses under load. How do you troubleshoot and optimize?</p>
            <p><strong>Answer:</strong></p>
            <p>Steps to troubleshoot:</p>
            <ol>
                <li>
                    <p><strong>Profiling / Diagnostics</strong><br /> Use tools like dotnet-trace, PerfView, Visual Studio Diagnostic Tools, logs &amp; metrics. Identify expensive calls, memory allocation hotspots.</p>
                </li>
                <li>
                    <p><strong>Reduce allocations</strong></p>
                    <ul>
                        <li>
                            <p>Avoid creating many short-lived objects; reuse objects.</p>
                        </li>
                        <li>
                            <p>Use <code>Span&lt;T&gt;</code>, <code>Memory&lt;T&gt;</code>, pooling (ArrayPool) for buffers.</p>
                        </li>
                        <li>
                            <p>Use <code>StringBuilder</code> instead of string concatenation in loops.</p>
                        </li>
                    </ul>
                </li>
                <li>
                    <p><strong>Optimize queries &amp; data access</strong></p>
                    <ul>
                        <li>
                            <p>Use <code>.AsNoTracking()</code> if tracking isn&rsquo;t needed.</p>
                        </li>
                        <li>
                            <p>Use projection (select only needed fields).</p>
                        </li>
                        <li>
                            <p>Avoid N+1 queries; use eager loading / batching.</p>
                        </li>
                    </ul>
                </li>
                <li>
                    <p><strong>Caching</strong></p>
                    <ul>
                        <li>
                            <p>Use in-memory cache or distributed cache (e.g. Redis) for expensive things.</p>
                        </li>
                        <li>
                            <p>Response caching, output caching where possible.</p>
                        </li>
                    </ul>
                </li>
                <li>
                    <p><strong>Optimize serialization</strong></p>
                    <ul>
                        <li>
                            <p>Use <code>System.Text.Json</code> instead of older JSON libs when performance matters. Possibly enable source generators.</p>
                        </li>
                    </ul>
                </li>
                <li>
                    <p><strong>Request pipeline optimizations</strong></p>
                    <ul>
                        <li>
                            <p>Reduce middleware where not necessary; order them properly.</p>
                        </li>
                        <li>
                            <p>Use HTTP/2, compression, GZIP, etc.</p>
                        </li>
                    </ul>
                </li>
                <li>
                    <p><strong>Scaling &amp; architecture</strong></p>
                    <ul>
                        <li>
                            <p>Horizontal scaling (multiple instances behind a load balancer).</p>
                        </li>
                        <li>
                            <p>Use asynchronous processing / message queues to offload work.</p>
                        </li>
                    </ul>
                </li>
            </ol>
            <p><strong>Example:</strong></p>
            <blockquote>
                <p>&ldquo;We saw GC pressure due to frequent allocations of large buffers for file uploads. Switched to using pooled buffers, limited concurrency for uploads, moved heavy processing to background service, and saw memory usage drop by 60%. Also changed JSON serialization to System.Text.Json with custom converters and got response times down.&rdquo;</p>
            </blockquote>
            <hr />
            <h3>6. Middleware, Pipelines, Filters, and Request Handling in ASP.NET Core</h3>
            <p><strong>Question:</strong> What is middleware in ASP.NET Core? How is it different from filters (action filters etc.)? Can you walk through how ASP.NET Core processes a request?</p>
            <p><strong>Answer:</strong></p>
            <ul>
                <li>
                    <p><strong>Middleware</strong>: Components in a pipeline that receive request, can process, then call next, or short-circuit. They are global to all requests (unless conditionally used). Good for cross-cutting concerns: authentication, logging, error handling, response compression, CORS.</p>
                </li>
                <li>
                    <p><strong>Filters (ActionFilters, ResourceFilters, AuthorizationFilters etc.)</strong>: Part of MVC; more fine-grained; apply to controllers/actions; can inspect/modify action execution. Useful for per-controller or per-action concerns.</p>
                </li>
                <li>
                    <p><strong>Request pipeline</strong>:</p>
                    <ol>
                        <li>
                            <p>HTTP request arrives at server (Kestrel / web server)</p>
                        </li>
                        <li>
                            <p>Middlewares execute in order: routing, authentication, authorization, etc.</p>
                        </li>
                        <li>
                            <p>Routing middleware matches route, maps route to endpoint.</p>
                        </li>
                        <li>
                            <p>If MVC controllers, filters execute around action execution.</p>
                        </li>
                        <li>
                            <p>Controller action executes; result produced.</p>
                        </li>
                        <li>
                            <p>Response travels back through middleware pipeline (if some middleware after next) to do post-processing.</p>
                        </li>
                    </ol>
                </li>
            </ul>
            <p><strong>Example:</strong></p>
<pre><code class="language-csharp">app.UseMiddleware&lt;ErrorHandlingMiddleware&gt;();
app.UseHttpsRedirection();
app.UseRouting();
app.UseAuthentication();
app.UseAuthorization();
app.UseEndpoints(endpoints =&gt;
{
    endpoints.MapControllers();
});
</code></pre>
            <p>An ActionFilter might enforce a certain header on specific controllers, whereas Middleware would do something for all requests globally.</p>
            <hr />
            <h3>7. Microservices, Distributed Systems, and Data Consistency</h3>
            <p><strong>Question:</strong> Suppose you are migrating from a monolith to microservices using .NET Core. What are the challenges you expect, and how would you ensure data consistency, resilience, and orchestration?</p>
            <p><strong>Answer:</strong></p>
            <ul>
                <li>
                    <p><strong>Challenges:</strong></p>
                    <ul>
                        <li>
                            <p>Service boundaries, ownership of data.</p>
                        </li>
                        <li>
                            <p>Inter-service communication latency and failures.</p>
                        </li>
                        <li>
                            <p>Distributed transactions vs eventual consistency.</p>
                        </li>
                        <li>
                            <p>Versioning of APIs.</p>
                        </li>
                        <li>
                            <p>Infrastructure needs: containerization, service discovery, monitoring, logging/tracing.</p>
                        </li>
                        <li>
                            <p>Deployment &amp; operational complexity.</p>
                        </li>
                    </ul>
                </li>
                <li>
                    <p><strong>Ensuring data consistency/resilience:</strong></p>
                    <ul>
                        <li>
                            <p>Use event-driven architecture / message bus (RabbitMQ, Azure Service Bus, Kafka).</p>
                        </li>
                        <li>
                            <p>Use patterns like <strong>Saga</strong> for long-running transactions.</p>
                        </li>
                        <li>
                            <p>Design for idempotency in APIs &amp; message handlers.</p>
                        </li>
                        <li>
                            <p>Circuit breakers, retries, fallback strategies.</p>
                        </li>
                        <li>
                            <p>Distributed tracing (e.g. OpenTelemetry), structured logging.</p>
                        </li>
                    </ul>
                </li>
                <li>
                    <p><strong>Orchestration &amp; deployment:</strong></p>
                    <ul>
                        <li>
                            <p>Docker, Kubernetes (or managed services).</p>
                        </li>
                        <li>
                            <p>CI/CD pipelines with blue-green/rolling deployments.</p>
                        </li>
                        <li>
                            <p>Monitoring &amp; alerting.</p>
                        </li>
                    </ul>
                </li>
            </ul>
            <p><strong>Example:</strong></p>
            <blockquote>
                <p>&ldquo;We separated orders and inventory into two microservices. When order placed, we emitted an event. Inventory service listens and decrements stock. If stock insufficient, a compensating action is triggered. We used Azure Service Bus. We designed handlers to be idempotent. We set up retry policies and a dead-letter queue. For observability, we used OpenTelemetry to trace requests across services.&rdquo;</p>
            </blockquote>
            <hr />
            <h3>8. Logging, Monitoring, Telemetry, and Diagnostics</h3>
            <p><strong>Question:</strong> How do you approach logging, tracing, metrics, and diagnosing production issues in .NET Core applications?</p>
            <p><strong>Answer:</strong></p>
            <ul>
                <li>
                    <p><strong>Logging</strong>: Use built-in logging abstractions (<code>ILogger&lt;T&gt;</code>) so you can plug in providers (Console, File, Seq, Application Insights, etc.). Log at appropriate levels (Debug, Info, Warning, Error, Critical). Don&rsquo;t over-log (avoid performance/IO overhead).</p>
                </li>
                <li>
                    <p><strong>Tracing / Correlation</strong>: Use correlation IDs, include in logs, propagate across services. Use distributed tracing (OpenTelemetry, Application Insights) to see end-to-end request flow.</p>
                </li>
                <li>
                    <p><strong>Metrics</strong>: Capture latency, error rates, throughput. Use tools like Prometheus + Grafana, or Azure Monitor. Set up health checks and readiness checks.</p>
                </li>
                <li>
                    <p><strong>Diagnostics</strong>: Use performance metrics, memory dumps, profiling tools. Capture key metrics under load. Have ability to reproduce or simulate load.</p>
                </li>
                <li>
                    <p><strong>Alerting &amp; SLIs / SLOs</strong>: Define service-level indicators/objectives; set alerts.</p>
                </li>
            </ul>
            <p><strong>Example:</strong></p>
            <blockquote>
                <p>&ldquo;In one production service we had random spikes. We instrumented endpoints with OpenTelemetry. We included correlation IDs in HTTP headers so that when a request fails, we can trace through all services. We also added health endpoints (liveness/readiness), set up dashboards in Grafana. For one issue, the trace showed repeated retries to a downstream service which increased latency; we added retry + timeout + fallback which stopped those cascading failures.&rdquo;</p>
            </blockquote>
            <hr />
            <h3>9. Dependency Injection, IoC, and Managing Service Lifetimes</h3>
            <p><strong>Question:</strong> How is dependency injection implemented in .NET Core? What service lifetimes are there? What common pitfalls have you faced and how did you avoid them?</p>
            <p><strong>Answer:</strong></p>
            <ul>
                <li>
                    <p>.NET Core has built-in DI container: <code>ConfigureServices(...)</code> where you register services (Interfaces to Implementations).</p>
                </li>
                <li>
                    <p><strong>Lifetimes:</strong></p>
                    <ul>
                        <li>
                            <p><strong>Transient</strong> &ndash; new instance each time.</p>
                        </li>
                        <li>
                            <p><strong>Scoped</strong> &ndash; one per request (in web apps).</p>
                        </li>
                        <li>
                            <p><strong>Singleton</strong> &ndash; one for the entire application lifetime.</p>
                        </li>
                    </ul>
                </li>
                <li>
                    <p><strong>Pitfalls:</strong></p>
                    <ul>
                        <li>
                            <p>Having stateful singletons (shared state) that can cause threading issues.</p>
                        </li>
                        <li>
                            <p>Injecting scoped services into singletons (can lead to capturing a scoped service beyond its lifetime).</p>
                        </li>
                        <li>
                            <p>Over-injecting / large constructor parameter lists.</p>
                        </li>
                    </ul>
                </li>
                <li>
                    <p>Use factory patterns, abstractions. Clean up disposable services properly.</p>
                </li>
            </ul>
            <p><strong>Example:</strong></p>
<pre><code class="language-csharp">services.AddSingleton&lt;IMySingletonService, MySingletonService&gt;();
services.AddScoped&lt;IMyScopedService, MyScopedService&gt;();
services.AddTransient&lt;IMyTransientService, MyTransientService&gt;();
</code></pre>
            <p>Avoid:</p>
<pre><code class="language-csharp">// bad - injecting scoped into singleton
public class MySingletonService
{
    private readonly IMyScopedService _scoped;
    public MySingletonService(IMyScopedService scoped) { _scoped = scoped; }
}
</code></pre>
            <hr />
            <h3>10. Testing Strategy: Unit, Integration, End-to-End, and Mocking</h3>
            <p><strong>Question:</strong> What testing strategy do you follow for a complex .NET Core system? How do you ensure tests are reliable and maintainable?</p>
            <p><strong>Answer:</strong></p>
            <ul>
                <li>
                    <p><strong>Unit tests</strong> first: test small pieces in isolation using mocking (Moq etc.). Keep them fast.</p>
                </li>
                <li>
                    <p><strong>Integration tests</strong> for data access, external dependencies (e.g. databases, file storage) using in-memory providers or test databases.</p>
                </li>
                <li>
                    <p><strong>End-to-End (E2E)</strong> or contract tests for critical flows.</p>
                </li>
                <li>
                    <p>Use CI/CD to run tests automatically.</p>
                </li>
                <li>
                    <p>Ensure test data is deterministic; use fixtures; avoid flaky tests.</p>
                </li>
                <li>
                    <p>Use dependency inversion to make mocking easier; design for testability.</p>
                </li>
            </ul>
            <p><strong>Example:</strong></p>
            <blockquote>
                <p>&ldquo;We set up a test suite: units tests run on every PR (~ 1000 tests), integration tests run nightly (in staging environment, hitting real DB). For mocking, we use Moq, sometimes substitutes. For API contracts, we use Postman/Newman test runs. We also have acceptance tests. Flaky tests are quarantined and fixed immediately. Coverage threshold enforced via policy.&rdquo;</p>
            </blockquote>
            <hr />
            <h3>11. Real-World Refactoring / Legacy Code Scenarios</h3>
            <p><strong>Question:</strong> You have a large, messy .NET Core codebase with high coupling, duplicated logic, weak error handling, no tests. How would you approach refactoring it while minimizing risk and ensuring continuous delivery?</p>
            <p><strong>Answer:</strong></p>
            <ul>
                <li>
                    <p>Understand current state: map dependencies, use code metrics (complexity, hotspots). Identify pain points.</p>
                </li>
                <li>
                    <p>Introduce tests: Before changing code, write characterization tests (to capture current behavior).</p>
                </li>
                <li>
                    <p>Incremental refactoring: Use Facade pattern, extract services, apply the Strangler pattern (gradually replace modules).</p>
                </li>
                <li>
                    <p>Improve architecture module by module. Clean up duplicated code; share common functionality via libraries.</p>
                </li>
                <li>
                    <p>Introduce better error handling, logging.</p>
                </li>
                <li>
                    <p>Make small safe changes; CI/CD ensures quick feedback.</p>
                </li>
                <li>
                    <p>Ensure feature flags/toggles in case new refactor introduces regressions so roll backs or toggles are possible.</p>
                </li>
            </ul>
            <p><strong>Example:</strong></p>
            <blockquote>
                <p>&ldquo;At one company we had a monolithic ASP.NET Core MVC app with shared dependencies and duplication. We first wrote characterization tests around the core business workflows. Then extracted data access logic into a separate library. Introduced a service layer. For parts we needed to replace, we used the Strangler pattern&mdash;new services behind an API gateway, routing some endpoints to new services, leaving the rest behind until ready. We rolled out in stages, with feature toggles so we could switch back if any issues.&rdquo;</p>
            </blockquote>
            <hr />
            <h2>🧮 Additional &ldquo;Leadership / Senior-Level&rdquo; / Behavioral Questions</h2>
            <hr />
        </div>
    </TabPage>
</TabControl>
@code {

}

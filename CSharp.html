<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>C#</title>
    <style>
        body {
            max-width: 980px;
            margin: auto;
        }

        .title {
            text-align: center;
            margin: 10px;
        }

        .collapsible {
            background-color: #777;
            color: white;
            cursor: pointer;
            padding: 5px;
            /* width: 100%; */
            border: none;
            text-align: left;
            outline: none;
            font-size: 11px;
        }

        .active,
        .collapsible:hover {
            background-color: #555;
        }

        .contentroot {
            background: white !important;            
        }

        .content {
            padding: 0 18px;
            display: none;
            overflow: hidden;
            background-color: #f9f9f9;
            border-top-left-radius: .375rem;
            border-top-right-radius: .375rem;            
        }
    </style>
</head>

<body>
    <div class="title">
        <h1>C# concepts</h1>
        <hr>
    </div>

    <p>
        <strong>C# is a versatile, modern programming language developed by Microsoft.
            It’s often used for building web, desktop, and mobile applications, as
            well as games and cloud-based services.</strong>
    </p>

    <button type="button" class="collapsible">Fundamentals</button>
    <div class="content contentroot">
        <h3>1. <strong>Basic Syntax and Structure</strong></h3>

        <ul>
            <li>
                <strong>Namespaces</strong>: C# organizes code into
                <strong>namespaces</strong> to help avoid naming conflicts and make code
                more modular. <code>System</code> is a default namespace that includes
                common classes like <code>Console</code>.
            </li>
            <li>
                <strong>Classes and Objects</strong>: C# is an object-oriented language,
                meaning everything revolves around <strong>classes</strong> and
                <strong>objects</strong>. A class defines the structure and behavior of
                objects, which are instances of classes.
            </li>
        </ul>

        <button type="button" class="collapsible">Code</button>
        <div class="content">
            <pre>
        <code>
            using System;

            namespace MyApp
            {
                class Program
                {
                    static void Main(string[] args)
                    {
                        Console.WriteLine("Hello, World!");
                    }
                }
            }
          </code>
    </pre>
        </div>
        <hr />
        <h3>2. <strong>Data Types and Variables</strong></h3>
        <ul>
            <li>
                <p>
                    <strong>Primitive Data Types</strong>: C# includes various data types,
                    such as:
                </p>
                <ul>
                    <li><code>int</code>: integer (e.g., 5)</li>
                    <li><code>double</code>: floating-point number (e.g., 5.5)</li>
                    <li><code>char</code>: single character (e.g., 'A')</li>
                    <li><code>bool</code>: boolean (true or false)</li>
                    <li><code>string</code>: sequence of characters (e.g., "Hello")</li>
                </ul>
            </li>
            <li>
                <p>
                    <strong>Variables</strong>: Variables are containers for storing data
                    values. In C#, variables need to be declared with a type, making it a
                    <strong>strongly-typed language</strong>.
                </p>
            </li>
        </ul>

        <button type="button" class="collapsible">Code</button>
        <div class="content">
            <pre>
        <code>
            int number = 10;
            double pi = 3.14;
            string name = "C#";
            bool isAwesome = true;            
        </code>
    </pre>
        </div>
        <hr />

        <h3>3. <strong>Control Flow Statements</strong></h3>
        <p>Control flow statements control the execution path in a program.</p>
        <ul>
            <li>
                <strong>Conditionals</strong>: <code>if</code>, <code>else if</code>,
                and <code>else</code> statements control logic based on conditions.
            </li>
            <li><strong>Switch</strong>: Allows selection among multiple options.</li>
            <li>
                <strong>Loops</strong>: C# supports various loops, such as:
                <ul>
                    <li>
                        <code>for</code> loop: Runs a block of code a specified number of
                        times.
                    </li>
                    <li>
                        <code>while</code> loop: Runs a block of code while a condition is
                        true.
                    </li>
                    <li>
                        <code>do-while</code> loop: Similar to <code>while</code>, but
                        checks the condition after the first execution.
                    </li>
                    <li>
                        <code>foreach</code> loop: Used to iterate through collections like
                        arrays or lists.
                    </li>
                </ul>
            </li>
        </ul>

        <button type="button" class="collapsible">Code</button>
        <div class="content">
            <pre>
        <code>
            int num = 10;

            if (num > 5)
            {
                Console.WriteLine("Greater than 5");
            }
            else
            {
                Console.WriteLine("5 or less");
            }
            
            for (int i = 0; i < 5; i++)
            {
                Console.WriteLine(i);  // Outputs 0 to 4
            }           
        </code>
    </pre>
        </div>

        <hr />
        <h3>4. <strong>Methods</strong></h3>
        <p>
            <strong>Methods</strong> are reusable blocks of code that perform specific
            tasks. They allow you to structure code better and avoid repetition. A
            method can return a value or be <code>void</code> (returning nothing).
        </p>
        <button type="button" class="collapsible">Code</button>
        <div class="content">
            <pre>
        <code>
            using System;

            class Program
            {
                static void Main(string[] args)
                {
                    int sum = Add(5, 3);
                    Console.WriteLine("Sum: " + sum);
                }
            
                static int Add(int a, int b)
                {
                    return a + b;
                }
            }           
        </code>
    </pre>
        </div>

        <hr />

        <h3>5. <strong>Object-Oriented Programming (OOP)</strong></h3>
        <p>
            C# is built on <strong>OOP principles</strong>, including
            <strong>Encapsulation</strong>, <strong>Inheritance</strong>,
            <strong>Polymorphism</strong>, and <strong>Abstraction</strong>.
        </p>
        <ul>
            <li>
                <strong>Encapsulation</strong>: Grouping related variables and methods
                in classes and controlling access with access modifiers
                (<code>public</code>, <code>private</code>, <code>protected</code>).
            </li>
            <li>
                <strong>Inheritance</strong>: Allows one class to inherit fields and
                methods from another class.
            </li>
            <li>
                <strong>Polymorphism</strong>: Methods can behave differently based on
                the object that invokes them.
            </li>
            <li>
                <strong>Abstraction</strong>: Simplifying complex systems by breaking
                them into classes with clear, easy-to-use interfaces.
            </li>
        </ul>

        <button type="button" class="collapsible">Code</button>
        <div class="content">
            <pre>
        <code>
            class Animal
            {
                public void Speak()
                {
                    Console.WriteLine("Animal sound");
                }
            }
            
            class Dog : Animal
            {
                public void Bark()
                {
                    Console.WriteLine("Dog barks");
                }
            }                       
        </code>
    </pre>
        </div>

        <hr>
        <h3>6. <strong>Collections and Arrays</strong></h3>
        <p>Collections store multiple items of data together. In C#, we have various types of collections:</p>
        <ul>
            <li><strong>Arrays</strong>: Fixed-size collection of items of the same type.</li>
            <li><strong>List</strong>: A dynamic-sized collection.</li>
            <li><strong>Dictionary</strong>: Key-value pairs, useful for mapping.</li>
        </ul>
        <button type="button" class="collapsible">Code</button>
        <div class="content">
            <pre>
        <code>
            int[] numbers = { 1, 2, 3 };
            List<string> names = new List<string>() { "Alice", "Bob" };
            Dictionary<string, int> ageMap = new Dictionary<string, int>()
            {
                { "Alice", 25 },
                { "Bob", 30 }
            };
        </code>
    </pre>
        </div>
        <hr>

        <h3>7. <strong>Error Handling</strong></h3>
        <p>C# uses <strong>try-catch</strong> blocks to handle exceptions, which are runtime errors that disrupt program
            flow. <code>finally</code> can be used to execute code regardless of the success or failure of the
            <code>try</code> block.
        </p>

        <button type="button" class="collapsible">Code</button>
        <div class="content">
            <pre>
        <code>
            try
            {
                int result = 10 / 0;
            }
            catch (DivideByZeroException e)
            {
                Console.WriteLine("Cannot divide by zero.");
            }
            finally
            {
                Console.WriteLine("Finished error handling.");
            }
        </code>
    </pre>
        </div>
        <hr>

        <h3>8. <strong>Asynchronous Programming (Async/Await)</strong></h3>
        <p><strong>Async/await</strong> is used for asynchronous operations that improve responsiveness, such as network
            requests or long-running calculations.</p>

        <button type="button" class="collapsible">Code</button>
        <div class="content">
            <pre>
        <code>
            using System;
            using System.Threading.Tasks;
            
            class Program
            {
                static async Task Main()
                {
                    await DoAsyncTask();
                }
            
                static async Task DoAsyncTask()
                {
                    await Task.Delay(2000);  // Asynchronously wait 2 seconds
                    Console.WriteLine("Task complete.");
                }
            }
        </code>
    </pre>
        </div>
        <hr>

        <h3>9. <strong>LINQ (Language Integrated Query)</strong></h3>
        <p><strong>LINQ</strong> is a query syntax in C# used for filtering, sorting, and manipulating collections.</p>
        <button type="button" class="collapsible">Code</button>
        <div class="content">
            <pre>
        <code>
            using System;
            using System.Linq;
            
            class Program
            {
                static void Main()
                {
                    int[] numbers = { 1, 2, 3, 4, 5 };
                    var evenNumbers = numbers.Where(n => n % 2 == 0);
            
                    foreach (var n in evenNumbers)
                    {
                        Console.WriteLine(n);  // Outputs: 2, 4
                    }
                }
            }
        </code>
    </pre>
        </div>
        <hr>


        <h3>10. <strong>Access Modifiers</strong></h3>
        <p>Access modifiers in C# control the visibility of classes, methods, and properties:</p>
        <ul>
            <li><strong>public</strong>: Accessible from any class.</li>
            <li><strong>private</strong>: Accessible only within the same class.</li>
            <li><strong>protected</strong>: Accessible within the same class or subclasses.</li>
            <li><strong>internal</strong>: Accessible only within the same assembly.</li>
        </ul>
        <button type="button" class="collapsible">Code</button>
        <div class="content">
            <pre>
        <code>
            class MyClass
            {
                public int PublicVar;    // Accessible anywhere
                private int PrivateVar;  // Accessible only within MyClass
            }
        </code>
    </pre>
        </div>
    </div>
    <hr>

    <button type="button" class="collapsible">Features</button>
    <div class="content contentroot">

    <h3>1. <strong>Object-Oriented Programming (OOP) Principles</strong></h3>
    <p>OOP is a paradigm that structures code around <strong>objects</strong> and the operations that can be performed
        on them. C# is highly OOP-oriented, which means it leverages <strong>classes</strong>,
        <strong>inheritance</strong>, <strong>polymorphism</strong>, <strong>abstraction</strong>, and
        <strong>encapsulation</strong> to make code more modular, reusable, and maintainable.
    </p>
    <h4>OOP Principles in Detail</h4>
    <ol>
        <li>
            <p><strong>Encapsulation</strong></p>
            <ul>
                <li>Encapsulation is about <strong>bundling data and methods</strong> that operate on that data within a
                    single unit, called a <strong>class</strong>.</li>
                <li><strong>Access modifiers</strong> (<code>private</code>, <code>public</code>,
                    <code>protected</code>) control visibility, hiding internal details and allowing only necessary
                    parts to be accessed by other classes.
                </li>
            </ul>
            <button type="button" class="collapsible">Code</button>
            <div class="content">
                <pre>
            <code>
                class BankAccount
                {
                    private decimal balance; // Encapsulated field
                
                    public void Deposit(decimal amount)
                    {
                        if (amount > 0)
                        {
                            balance += amount;
                        }
                    }
                
                    public decimal GetBalance()
                    {
                        return balance; // Controlled access to the balance
                    }
                }    
            </code>
        </pre>
            </div>
        </li>
        <li>
            <p><strong>Inheritance</strong></p>
            <ul>
                <li>Inheritance allows one class (called the <strong>derived</strong> or <strong>child</strong> class)
                    to inherit properties and methods from another class (called the <strong>base</strong> or
                    <strong>parent</strong> class).
                </li>
                <li>It enables <strong>code reuse</strong> and helps establish relationships between classes.</li>
            </ul>
            <button type="button" class="collapsible">Code</button>
            <div class="content">
                <pre>
            <code>
                class Animal
                {
                    public void Eat()
                    {
                        Console.WriteLine("Eating...");
                    }
                }
                
                class Dog : Animal // Dog inherits from Animal
                {
                    public void Bark()
                    {
                        Console.WriteLine("Barking...");
                    }
                }
                
                // Usage
                Dog dog = new Dog();
                dog.Eat(); // Inherited method
                dog.Bark();    
            </code>
        </pre>
            </div>
        </li>
        <li>
            <p><strong>Polymorphism</strong></p>
            <ul>
                <li>Polymorphism allows methods to <strong>take on many forms</strong>, letting you call a derived class
                    method through a base class reference.</li>
                <li>This is achieved using <strong>method overriding</strong> and <strong>virtual/override
                        keywords</strong>.</li>
            </ul>
            <button type="button" class="collapsible">Code</button>
            <div class="content">
                <pre>
            <code>
                class Animal
                {
                    public virtual void Speak()
                    {
                        Console.WriteLine("Animal sound");
                    }
                }
                
                class Dog : Animal
                {
                    public override void Speak()
                    {
                        Console.WriteLine("Woof!");
                    }
                }
                
                // Usage
                Animal myDog = new Dog();
                myDog.Speak(); // Outputs: Woof!  
            </code>
        </pre>
            </div>
        </li>
        <li>
            <p><strong>Abstraction</strong></p>
            <ul>
                <li>Abstraction is the process of <strong>hiding complex implementation details</strong> and exposing
                    only the necessary features.</li>
                <li>It’s commonly implemented using <strong>abstract classes</strong> and <strong>interfaces</strong> in
                    C#.</li>
            </ul>
            <button type="button" class="collapsible">Code</button>
            <div class="content">
                <pre>
        <code>
            abstract class Shape
            {
                public abstract double GetArea(); // Abstract method with no implementation
            }
            
            class Circle : Shape
            {
                private double radius;
            
                public Circle(double radius)
                {
                    this.radius = radius;
                }
            
                public override double GetArea()
                {
                    return Math.PI * radius * radius;
                }
            }
            
        </code>
    </pre>
            </div>
        </li>
    </ol>

    <hr>

    <h3>2. <strong>Asynchronous Programming with Async/Await</strong></h3>
    <p><strong>Asynchronous programming</strong> allows programs to handle long-running tasks, like file operations or
        network requests, without blocking the main thread. In C#, async programming is achieved through the
        <strong>async</strong> and <strong>await</strong> keywords.
    </p>
    <h4>Async/Await in Detail</h4>

    <ol>
        <li>
            <p><strong>Async Methods</strong>:</p>
            <ul>
                <li>A method marked with <code>async</code> can contain <code>await</code> expressions.</li>
                <li>An <code>async</code> method typically returns a <code>Task</code> or <code>Task&lt;T&gt;</code> (or
                    <code>void</code> for event handlers).
                </li>
            </ul>
        </li>
        <li>
            <p><strong>Await</strong>:</p>
            <ul>
                <li>The <code>await</code> keyword <strong>pauses the method execution</strong> until the awaited task
                    completes, allowing other tasks to run in the meantime.</li>
                <li>Awaiting a task makes the program non-blocking and improves responsiveness.</li>
            </ul>
            <button type="button" class="collapsible">Code</button>
            <div class="content">
                <pre>
                <code>
                    using System;
                    using System.Threading.Tasks;
                    
                    class Program
                    {
                        static async Task Main()
                        {
                            Console.WriteLine("Starting...");
                            await PerformTaskAsync();
                            Console.WriteLine("Finished.");
                        }
                    
                        static async Task PerformTaskAsync()
                        {
                            Console.WriteLine("Waiting for 3 seconds...");
                            await Task.Delay(3000); // Simulates a long-running task
                            Console.WriteLine("Task Complete.");
                        }
                    }        
                </code>
            </pre>
            </div>
            <p><strong>Explanation</strong>:</p>
            <ul>
                <li><code>Task.Delay(3000)</code> simulates a delay of 3 seconds.</li>
                <li><code>await Task.Delay(3000)</code> does not block the main thread; it pauses
                    <code>PerformTaskAsync</code> until the delay is over, then resumes the method.
                </li>
            </ul>
        </li>
        <li>
            <p><strong>When to Use Async Programming</strong></p>
            <ul>
                <li>Async programming is ideal for <strong>I/O-bound tasks</strong>, like network requests, file I/O,
                    and database queries, where you want to avoid blocking the main thread.</li>
                <li>It should be avoided for <strong>CPU-bound tasks</strong> that require significant computation.</li>
            </ul>
        </li>
    </ol>

    <hr>
    <h3>3. <strong>LINQ (Language Integrated Query)</strong></h3>
    <p><strong>LINQ</strong> is a powerful feature in C# that allows you to query and manipulate collections, databases,
        XML documents, and more using a syntax similar to SQL.</p>
    <h4>LINQ Concepts and Methods</h4>
    <ol>
        <li>
            <p><strong>Syntax and Query Types</strong>:</p>
            <ul>
                <li>LINQ queries can be written using <strong>query syntax</strong> (like SQL) or <strong>method
                        syntax</strong> (using lambda expressions).</li>
            </ul>
        </li>
        <li>
            <p><strong>Common LINQ Methods</strong>:</p>
            <ul>
                <li><strong>Where</strong>: Filters a sequence based on a condition.</li>
                <li><strong>Select</strong>: Projects each element into a new form.</li>
                <li><strong>OrderBy/ThenBy</strong>: Sorts a sequence in ascending order.</li>
                <li><strong>GroupBy</strong>: Groups elements based on a specified key.</li>
                <li><strong>Aggregate</strong>: Performs a custom aggregation operation.</li>
                <li><strong>Sum/Count/Min/Max</strong>: Standard aggregate functions.</li>
            </ul>
            <button type="button" class="collapsible">Code</button>
            <div class="content">
                <pre>
                <code>
                    using System;
                    using System.Collections.Generic;
                    using System.Linq;
                    
                    class Program
                    {
                        static void Main()
                        {
                            List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
                    
                            // Query syntax example
                            var evenNumbers = from num in numbers
                                              where num % 2 == 0
                                              select num;
                    
                            // Method syntax example
                            var evenNumbersMethod = numbers.Where(num => num % 2 == 0);
                    
                            Console.WriteLine("Even numbers:");
                            foreach (var num in evenNumbers)
                            {
                                Console.WriteLine(num);
                            }
                        }
                    }
                </code>
            </pre>
            </div>
            <p><strong>Explanation</strong>:</p>
            <ul>
                <li>The <code>Where</code> method filters numbers to include only even numbers.</li>
                <li>LINQ query syntax (<code>from … where … select …</code>) provides a readable alternative to method
                    syntax and is similar to SQL.</li>
            </ul>
        </li>
        <li>
            <p><strong>Advantages of LINQ</strong>:</p>
            <ul>
                <li><strong>Readability</strong>: LINQ’s declarative syntax makes queries readable and concise.</li>
                <li><strong>Consistency</strong>: LINQ provides a consistent querying interface for various data
                    sources.</li>
                <li><strong>Less Code</strong>: LINQ reduces the need for loops and conditional statements, resulting in
                    cleaner code.</li>
            </ul>
        </li>
    </ol>
  
    <hr>

    <h3>4. <strong>Delegates</strong></h3>

    <p>Delegates are like function pointers or callbacks in other languages. They allow methods to be <strong>passed as
            parameters</strong>, stored as variables, and invoked dynamically. A delegate is a type-safe way to
        reference a method.</p>
    <h4>How Delegates Work:</h4>
    <ul>
        <li><strong>Declaration</strong>: A delegate type defines the signature (return type and parameters) of methods
            it can point to.</li>
        <li><strong>Instantiation</strong>: Create a delegate instance by assigning it a method that matches its
            signature.</li>
        <li><strong>Invocation</strong>: Call the delegate as if it were a method.</li>
    </ul>
    <button type="button" class="collapsible">Code</button>
    <div class="content">
        <pre>
        <code>
            using System;

            public delegate int MathOperation(int x, int y); // Delegate declaration
            
            class Program
            {
                static int Add(int a, int b)
                {
                    return a + b;
                }
            
                static int Multiply(int a, int b)
                {
                    return a * b;
                }
            
                static void Main()
                {
                    MathOperation operation;
            
                    operation = Add; // Assigning a method to the delegate
                    Console.WriteLine("Addition: " + operation(5, 3));
            
                    operation = Multiply; // Reassigning a different method
                    Console.WriteLine("Multiplication: " + operation(5, 3));
                }
            }
        </code>
    </pre>
    </div>
    <p><strong>Explanation</strong>:</p>
    <ul>
        <li><code>MathOperation</code> delegate can point to any method that has the same signature (int, int) → int.
        </li>
        <li>We can change which method <code>operation</code> points to dynamically and invoke it using
            <code>operation(5, 3)</code>.
        </li>
    </ul>
    <hr>

    <h3>5. <strong>Events</strong></h3>
    <p>Events are a way for a class to notify other classes when something happens. Events in C# are built on top of
        delegates, but they restrict the delegate by only allowing it to be invoked within the declaring class.</p>
    <h4>How Events Work:</h4>
    <ul>
        <li><strong>Declaration</strong>: Use the <code>event</code> keyword to declare an event based on a delegate.
        </li>
        <li><strong>Subscription</strong>: Other classes or methods can <strong>subscribe</strong> to an event with
            <code>+=</code> and <strong>unsubscribe</strong> with <code>-=</code>.
        </li>
        <li><strong>Invocation</strong>: The event can only be raised by the class that declared it, using the delegate
            invocation.</li>
    </ul>
    <button type="button" class="collapsible">Code</button>
    <div class="content">
        <pre>
        <code>
            using System;

            public delegate void Notify(); // Declare delegate
            
            class Process
            {
                public event Notify ProcessCompleted; // Declare event
            
                public void StartProcess()
                {
                    Console.WriteLine("Process Started!");
                    // Raise the event
                    ProcessCompleted?.Invoke(); // Check if the event has subscribers before invoking
                }
            }
            
            class Program
            {
                static void Main()
                {
                    Process process = new Process();
                    process.ProcessCompleted += ProcessCompletedHandler; // Subscribe to event
                    process.StartProcess();
                }
            
                static void ProcessCompletedHandler()
                {
                    Console.WriteLine("Process Completed!");
                }
            }
        </code>
    </pre>
    </div>
    <p><strong>Explanation</strong>:</p>
    <ul>
        <li><code>ProcessCompleted</code> is an event that is triggered (invoked) when <code>StartProcess</code> is
            called.</li>
        <li><code>ProcessCompletedHandler</code> is a method that gets called when <code>ProcessCompleted</code> is
            raised, providing a way to handle the event.</li>
    </ul>
    <hr>

    <h3>6. <strong>Generics</strong></h3>
    <p>Generics allow you to define <strong>type-safe data structures</strong> and methods without specifying the data
        types in advance. This increases code <strong>reusability</strong> and <strong>type safety</strong> while
        reducing redundancy.</p>
    <h4>How Generics Work:</h4>
    <ul>
        <li><strong>Generic Classes and Methods</strong>: You can define classes, methods, and interfaces with generic
            types by using <code>&lt;T&gt;</code> (or multiple types like <code>&lt;T, U&gt;</code>).</li>
        <li><strong>Type Constraint</strong>: You can add constraints on generic types using the <code>where</code>
            keyword (e.g., <code>where T : IComparable</code>).</li>
    </ul>
    <button type="button" class="collapsible">Code</button>
    <div class="content">
        <pre>
        <code>
            using System;

            public class Box<T>
            {
                private T content;
            
                public void Add(T item)
                {
                    content = item;
                }
            
                public T Get()
                {
                    return content;
                }
            }
            
            class Program
            {
                static void Main()
                {
                    Box<int> intBox = new Box<int>();
                    intBox.Add(10);
                    Console.WriteLine("IntBox contains: " + intBox.Get());
            
                    Box<string> stringBox = new Box<string>();
                    stringBox.Add("Hello");
                    Console.WriteLine("StringBox contains: " + stringBox.Get());
                }
            }
        </code>
    </pre>
    </div>
    <p><strong>Explanation</strong>:</p>
    <ul>
        <li><code>Box&lt;T&gt;</code> is a generic class, where <code>T</code> is a placeholder for any data type.</li>
        <li>We create instances with specific types (e.g., <code>Box&lt;int&gt;</code> and
            <code>Box&lt;string&gt;</code>), making the class reusable for different types without rewriting the code.
        </li>
    </ul>
    <hr>

    <h3>7. <strong>Dependency Injection (DI)</strong></h3>
    <p>Dependency Injection is a <strong>design pattern</strong> that helps to achieve <strong>Inversion of Control
            (IoC)</strong> by injecting dependencies into a class instead of creating them inside the class. DI improves
        modularity, testability, and reduces tight coupling.</p>
    <h4>Types of Dependency Injection:</h4>
    <ul>
        <li><strong>Constructor Injection</strong>: Dependencies are passed via a constructor.</li>
        <li><strong>Property Injection</strong>: Dependencies are set via properties.</li>
        <li><strong>Method Injection</strong>: Dependencies are passed directly into methods.</li>
    </ul>
    <button type="button" class="collapsible">Code</button>
    <div class="content">
        <h4>Example of Constructor Injection:</h4>
        <pre>
        <code>
            using System;

            public interface ILogger
            {
                void Log(string message);
            }
            
            public class ConsoleLogger : ILogger
            {
                public void Log(string message)
                {
                    Console.WriteLine("Log: " + message);
                }
            }
            
            public class AppService
            {
                private readonly ILogger _logger;
            
                // Constructor Injection
                public AppService(ILogger logger)
                {
                    _logger = logger;
                }
            
                public void Run()
                {
                    _logger.Log("AppService is running.");
                }
            }
            
            class Program
            {
                static void Main()
                {
                    ILogger logger = new ConsoleLogger();
                    AppService service = new AppService(logger); // Inject dependency
                    service.Run();
                }
            }
        </code>
    </pre>
    </div>
    <p><strong>Explanation</strong>:</p>
    <ul>
        <li><code>ILogger</code> is an interface for logging, while <code>ConsoleLogger</code> is an implementation.
        </li>
        <li><code>AppService</code> requires an <code>ILogger</code> instance, injected via the constructor, making it
            flexible and allowing different logging implementations (e.g., a <code>FileLogger</code>).</li>
        <li>Dependency Injection frameworks like <strong>Microsoft.Extensions.DependencyInjection</strong> can automate
            this injection process.</li>
    </ul>

    <h3>Summary</h3>
    <ul>
        <li><strong>OOP</strong> allows structuring complex systems with reusable and maintainable code.</li>
        <li><strong>Async/await</strong> helps handle time-consuming operations without blocking the application.</li>
        <li><strong>LINQ</strong> enables sophisticated data manipulation with clear, expressive queries.</li>
        <li><strong>Delegates</strong> enable method references and are useful for callbacks.</li>
        <li><strong>Events</strong> let a class notify other classes or components when something happens, which is key
            in event-driven programming.</li>
        <li><strong>Generics</strong> allow code reuse across different types, improving type safety and eliminating
            redundancy.</li>
        <li><strong>Dependency Injection</strong> fosters loosely-coupled, easily testable code by injecting
            dependencies rather than creating them within classes.</li>
    </ul>
    </div>
    <hr>

    <button type="button" class="collapsible">IoC container</button>
    <div class="content contentroot">
    <h3><strong>IoC (Inversion of Control) container</strong></h3>
    <p>An <strong>IoC (Inversion of Control) container</strong> is a framework that helps manage dependencies in an
        application. It automates <strong>Dependency Injection (DI)</strong>, allowing objects to be created and managed
        with minimal manual configuration. IoC containers play a significant role in reducing tight coupling, improving
        modularity, and enhancing testability in object-oriented programming.</p>
    <h3>How an IoC Container Works</h3>
    <ol>
        <li>
            <p><strong>Registration</strong>:</p>
            <ul>
                <li>In IoC, dependencies are registered with the container. This means you tell the container how to
                    provide an instance of each dependency.</li>
                <li>For example, if a class <code>AppService</code> requires an <code>ILogger</code>, we register
                    <code>ILogger</code> with its specific implementation (<code>ConsoleLogger</code>) in the container.
                </li>
            </ul>
        </li>
        <li>
            <p><strong>Resolution</strong>:</p>
            <ul>
                <li>The IoC container takes care of instantiating and injecting dependencies automatically whenever a
                    class needs them.</li>
                <li>When you request an instance of <code>AppService</code>, the container creates an
                    <code>ILogger</code> instance (<code>ConsoleLogger</code>), injects it into <code>AppService</code>,
                    and returns the <code>AppService</code> instance.
                </li>
            </ul>
        </li>
        <li>
            <p><strong>Lifetime Management</strong>:</p>
            <ul>
                <li>IoC containers also manage the <strong>lifecycle</strong> of objects, determining how long they
                    should live.</li>
                <li>Common lifetimes include:<ul>
                        <li><strong>Transient</strong>: New instance created each time.</li>
                        <li><strong>Scoped</strong>: A single instance for a given scope, often per request in web
                            applications.</li>
                        <li><strong>Singleton</strong>: A single instance throughout the application’s lifetime.</li>
                    </ul>
                </li>
            </ul>
        </li>
    </ol>
    <h3>Example Using Microsoft’s Built-in IoC Container</h3>
    <p>C#’s <code>Microsoft.Extensions.DependencyInjection</code> provides a built-in IoC container often used in
        ASP.NET Core and other .NET applications.</p>
    <h4>Step-by-Step Example</h4>
    <p>Let’s look at how to set up an IoC container using Dependency Injection in an ASP.NET Core-style application:</p>
    <ol>
        <li>
            <p><strong>Define Interfaces and Classes</strong>:</p>
            <pre>
                <code>
                    public interface ILogger
                    {
                        void Log(string message);
                    }
                    
                    public class ConsoleLogger : ILogger
                    {
                        public void Log(string message)
                        {
                            Console.WriteLine("Log: " + message);
                        }
                    }
                    
                    public class AppService
                    {
                        private readonly ILogger _logger;
                    
                        // The logger dependency is injected here
                        public AppService(ILogger logger)
                        {
                            _logger = logger;
                        }
                    
                        public void Run()
                        {
                            _logger.Log("AppService is running.");
                        }
                    }
                </code>
            </pre>
        </li>
        <li>
            <p><strong>Register Dependencies with the IoC Container</strong>:</p>
            <ul>
                <li>This is typically done in a <code>ConfigureServices</code> method in ASP.NET Core.</li>
            </ul>
            <pre>
                <code>
                    using Microsoft.Extensions.DependencyInjection;

                    var serviceProvider = new ServiceCollection()
                        .AddSingleton<ILogger, ConsoleLogger>() // Register ILogger to resolve to ConsoleLogger
                        .AddTransient<AppService>() // Register AppService with a transient lifetime
                        .BuildServiceProvider();
                </code>
            </pre>

        </li>
        <li>
            <p><strong>Request an Instance from the IoC Container</strong>:</p>
            <pre>
                <code>
                    var appService = serviceProvider.GetService<AppService>();
                        appService?.Run();
                </code>
            </pre>
            <p><strong>Explanation</strong>:</p>
            <ul>
                <li><code>AddSingleton&lt;ILogger, ConsoleLogger&gt;()</code>: This registers <code>ILogger</code> to
                    resolve to <code>ConsoleLogger</code> with a singleton lifetime, meaning the same instance of
                    <code>ConsoleLogger</code> is used across the application.
                </li>
                <li><code>AddTransient&lt;AppService&gt;()</code>: Registers <code>AppService</code> with a transient
                    lifetime, meaning a new instance is created every time it’s requested.</li>
                <li><code>serviceProvider.GetService&lt;AppService&gt;()</code>: The IoC container creates an
                    <code>AppService</code> instance and automatically injects an <code>ILogger</code> instance
                    (<code>ConsoleLogger</code>), fulfilling its dependencies.
                </li>
            </ul>
        </li>
    </ol>
    <h3>Benefits of Using an IoC Container</h3>
    <ul>
        <li><strong>Loose Coupling</strong>: Code components can depend on interfaces rather than specific
            implementations, making code easier to change and maintain.</li>
        <li><strong>Centralized Dependency Management</strong>: All dependencies are managed in one place, which
            simplifies debugging and configuration changes.</li>
        <li><strong>Improved Testability</strong>: Dependencies can easily be swapped with mock implementations during
            testing.</li>
        <li><strong>Lifecycle Control</strong>: IoC containers handle the lifecycle of dependencies, ensuring that
            objects are instantiated only as needed.</li>
    </ul>
    <h3>Common IoC Containers</h3>
    <p>Apart from <code>Microsoft.Extensions.DependencyInjection</code>, there are other popular IoC containers in .NET:
    </p>
    <ul>
        <li><strong>Autofac</strong>: Provides advanced features, such as nested containers and modular registration.
        </li>
        <li><strong>Ninject</strong>: Known for simplicity and easy configuration.</li>
        <li><strong>Unity</strong>: Developed by Microsoft, often used in enterprise applications.</li>
    </ul>
    <p>These containers add various customization options, allowing developers to manage complex dependency hierarchies
        and lifetimes in large applications.</p>
    </div>

    <hr>
    <button type="button" class="collapsible">Advanced Concepts</button>
    <div class="content contentroot">
    <h3>1. <strong>Reflection</strong></h3>
    <p>Reflection allows a C# program to <strong>inspect and interact with types and assemblies at runtime</strong>. It
        enables accessing metadata (like types, properties, methods) and manipulating objects dynamically, which can be
        powerful in scenarios like creating plugins, testing frameworks, and custom serializers.</p>
    <h4>Key Classes:</h4>
    <ul>
        <li><strong><code>Type</code></strong>: Represents type information, including properties, methods, fields, and
            events.</li>
        <li><strong><code>MethodInfo</code>, <code>PropertyInfo</code>, and FieldInfo`</strong>: Provide access to
            methods, properties, and fields on a type.</li>
        <li><strong><code>Activator</code></strong>: Allows creating instances of types dynamically.</li>
    </ul>
    <button type="button" class="collapsible">Code</button>
    <div class="content">
        <pre>
        <code>
            using System;
            using System.Reflection;
            
            public class Person
            {
                public string Name { get; set; }
                public void Greet()
                {
                    Console.WriteLine($"Hello, my name is {Name}!");
                }
            }
            
            class Program
            {
                static void Main()
                {
                    // Get Type metadata for Person
                    Type type = typeof(Person);
            
                    // Create an instance of Person dynamically
                    object personInstance = Activator.CreateInstance(type);
            
                    // Set the Name property
                    PropertyInfo nameProperty = type.GetProperty("Name");
                    nameProperty.SetValue(personInstance, "Alice");
            
                    // Invoke the Greet method
                    MethodInfo greetMethod = type.GetMethod("Greet");
                    greetMethod.Invoke(personInstance, null);
                }
            }
        </code>
    </pre>
    </div>
    <hr>

    <h3>2. <strong>Delegates and Lambda Expressions</strong></h3>
    <p>Delegates are objects that point to methods, allowing <strong>method references</strong> to be passed as
        parameters. <strong>Lambda expressions</strong> are concise ways of creating anonymous functions, simplifying
        delegate usage, and making code more readable.</p>
    <h4>Lambda Expressions:</h4>
    <ul>
        <li><strong>Syntax</strong>: <code>(parameters) =&gt; expression</code></li>
        <li>Lambdas can be used with LINQ and other data processing operations to filter, map, and reduce data.</li>
    </ul>
    <button type="button" class="collapsible">Code</button>
    <div class="content">
        <pre>
        <code>
            using System;
            using System.Collections.Generic;
            using System.Linq;
            
            class Program
            {
                static void Main()
                {
                    List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };
                    
                    // Use a lambda expression to filter even numbers
                    var evens = numbers.Where(n => n % 2 == 0);
                    
                    Console.WriteLine(string.Join(", ", evens)); // Output: 2, 4
                }
            }
        </code>
    </pre>
    </div>
    <hr>
    <h3>3. <strong>LINQ (Language Integrated Query) and LINQ Expressions</strong></h3>
    <p>LINQ enables querying collections and other data sources in a <strong>declarative, SQL-like syntax</strong>. LINQ
        expressions are objects that represent a query and can be dynamically built and executed, making LINQ versatile
        for building complex queries.</p>
    <button type="button" class="collapsible">Code</button>
    <div class="content">
        <pre>
        <code>
            using System;
            using System.Collections.Generic;
            using System.Linq;
            
            class Program
            {
                static void Main()
                {
                    List<string> fruits = new List<string> { "Apple", "Banana", "Cherry" };
                    
                    // Query syntax
                    var result = from fruit in fruits
                                 where fruit.Contains("a")
                                 select fruit;
                    
                    Console.WriteLine(string.Join(", ", result)); // Output: Banana
                }
            }
        </code>
    </pre>
    </div>
    <hr>
    <h3>4. <strong>Async Programming and Parallelism</strong></h3>
    <p><strong>Async/Await</strong> is used to perform <strong>asynchronous tasks without blocking the main
            thread</strong>, while <strong>Parallel LINQ (PLINQ)</strong> and the <strong>Task Parallel Library
            (TPL)</strong> help leverage multiple processors for concurrent execution.</p>
    <button type="button" class="collapsible">Code</button>
    <div class="content">
        <h4>Example with Async:</h4>
        <pre>
        <code>
            using System;
            using System.Threading.Tasks;
            
            class Program
            {
                static async Task Main()
                {
                    Console.WriteLine("Starting...");
                    await Task.Delay(2000); // Simulate async work
                    Console.WriteLine("Completed!");
                }
            }
        </code>
    </pre>
    </div>
    <hr>
    <h3>5. <strong>Extension Methods</strong></h3>
    <p>Extension methods allow adding new functionality to existing types <strong>without modifying the original
            type</strong> or creating a derived type. They are particularly useful for adding functionality to classes
        you don’t own or cannot modify, such as <code>System.String</code>.</p>
    <button type="button" class="collapsible">Code</button>
    <div class="content">
        <pre>
        <code>
            using System;

            public static class StringExtensions
            {
                public static bool IsLongerThan(this string str, int length)
                {
                    return str.Length > length;
                }
            }
            
            class Program
            {
                static void Main()
                {
                    string message = "Hello, World!";
                    Console.WriteLine(message.IsLongerThan(5)); // Output: True
                }
            }
            
        </code>
    </pre>
    </div>
    <hr>

    <h3>6. <strong>Dynamic Types</strong></h3>
    <p>The <code>dynamic</code> keyword bypasses compile-time type checking, enabling <strong>dynamic binding</strong>.
        This can be useful when working with data from sources like COM objects, scripting languages, or JSON objects
        where the structure may be unknown at compile time.</p>
    <button type="button" class="collapsible">Code</button>
    <div class="content">
        <pre>
        <code>
            using System;

            class Program
            {
                static void Main()
                {
                    dynamic obj = "Hello, Dynamic World!";
                    Console.WriteLine(obj.Length); // Runtime resolves Length property
                }
            }
            
        </code>
    </pre>
    </div>
    <hr>
    <h3>7. <strong>Dependency Injection (DI) and IoC Containers</strong></h3>
    <p><strong>Dependency Injection (DI)</strong> is a design pattern for achieving <strong>Inversion of Control
            (IoC)</strong>. It promotes <strong>loose coupling</strong> by allowing dependencies to be injected into
        objects rather than being created within them. IoC containers like
        <code>Microsoft.Extensions.DependencyInjection</code> manage object creation and lifecycle automatically.
    </p>
    <button type="button" class="collapsible">Code</button>
    <div class="content">
        <h4>Example with IoC:</h4>
        <pre>
        <code>
            using System;
            using Microsoft.Extensions.DependencyInjection;
            
            public interface ILogger
            {
                void Log(string message);
            }
            
            public class ConsoleLogger : ILogger
            {
                public void Log(string message)
                {
                    Console.WriteLine(message);
                }
            }
            
            class Program
            {
                static void Main()
                {
                    var serviceProvider = new ServiceCollection()
                        .AddSingleton<ILogger, ConsoleLogger>()
                        .BuildServiceProvider();
            
                    ILogger logger = serviceProvider.GetService<ILogger>();
                    logger.Log("Dependency Injection in action!");
                }
            }
        </code>
    </pre>
    </div>
    <hr>
    <h3>8. <strong>Memory Management and Span&lt;T&gt;</strong></h3>
    <p>C# provides <strong>stack allocation and span-based memory management</strong> for high-performance applications
        needing more control over memory usage. <strong>Span&lt;T&gt;</strong> and <strong>Memory&lt;T&gt;</strong> are
        stack-based data structures designed to manage slices of arrays, strings, and unmanaged memory regions with
        minimal allocations.</p>
    <button type="button" class="collapsible">Code</button>
    <div class="content">
        <pre>
        <code>
            using System;

            class Program
            {
                static void Main()
                {
                    Span<int> numbers = stackalloc int[] { 1, 2, 3, 4, 5 }; // Stack allocation
                    Console.WriteLine(numbers[1]); // Output: 2
                }
            }
        </code>
    </pre>
    </div>
    <hr>

    <h3>9. <strong>Pattern Matching</strong></h3>
    <p>Pattern matching allows more readable <strong>conditional code</strong>, especially with <code>switch</code>
        expressions, <code>is</code> expressions, and pattern-based <code>switch</code> cases, providing a more
        functional approach to type-checking and control flow.</p>
    <button type="button" class="collapsible">Code</button>
    <div class="content">
        <pre>
        <code>
            using System;

            class Program
            {
                static void Main()
                {
                    object obj = "Hello";
            
                    switch (obj)
                    {
                        case int i:
                            Console.WriteLine($"Integer: {i}");
                            break;
                        case string s:
                            Console.WriteLine($"String: {s}");
                            break;
                        default:
                            Console.WriteLine("Unknown type");
                            break;
                    }
                }
            }           
            
        </code>
    </pre>
    </div>
    <hr>

    <h3>10. <strong>Records and Immutable Types</strong></h3>
    <p>Introduced in C# 9, <strong>Records</strong> are a special kind of reference type focused on <strong>data
            immutability</strong> and <strong>structural equality</strong>. They are ideal for scenarios where you want
        immutable data objects with value-based equality rather than reference-based.</p>
    <button type="button" class="collapsible">Code</button>
    <div class="content">
        <pre>
        <code>
            public record Person(string FirstName, string LastName);

            class Program
            {
                static void Main()
                {
                    var person1 = new Person("John", "Doe");
                    var person2 = new Person("John", "Doe");
            
                    Console.WriteLine(person1 == person2); // True, checks value equality
                }
            }
        </code>
    </pre>
    </div>
    <hr>

    <h3>11. <strong>Nullable Reference Types</strong></h3>
    <p>Nullable Reference Types allow for <strong>nullability annotations</strong> and <strong>compile-time
            warnings</strong> about potential <code>null</code> reference errors. This feature helps in writing safer
        code by encouraging developers to handle <code>null</code> values explicitly.</p>
    <button type="button" class="collapsible">Code</button>
    <div class="content">
        <pre>
        <code>
            #nullable enable

            public class Person
            {
                public string? Name { get; set; } // Nullable reference type
            }
            
            class Program
            {
                static void Main()
                {
                    Person person = new Person();
                    Console.WriteLine(person.Name?.Length); // Safe access
                }
            }
        </code>
    </pre>
    </div>
    </div>
    <hr>

    <div>
        <h3>Help Links</h3>
        <ul>
            <li>
                <a href="https://www.geeksforgeeks.org/csharp-programming-language/">C# Overview - GeeksforGeeks</a>
            </li>
            <li>
               <a href="https://origin.geeksforgeeks.org/csharp-programming-language/" target="_blank">C# Tutorial - GeeksforGeeks</a> 
            </li>
            <li>
                <a href="https://www.javatpoint.com/c-sharp-function">Java point c#</a>
            </li>
        </ul>
    </div>


    <!-- <h4>example:</h4>
    <pre>
        <code>

        </code>
    </pre>
    <hr> -->


    <script>
        var coll = document.getElementsByClassName("collapsible");
        var i;

        for (i = 0; i < coll.length; i++) {
            coll[i].addEventListener("click", function () {
                //this.classList.toggle("active");
                var content = this.nextElementSibling;
                if (content.style.display === "block") {
                    content.style.display = "none";
                } else {
                    content.style.display = "block";
                }
            });
        }
    </script>
</body>

</html>
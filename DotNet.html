<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C# .Net</title>

    <style>
        table,
        th,
        td {
            border: 1px solid black;
            border-collapse: collapse;
        }
    </style>
</head>

<body>
    <h1>Dot NET Core</h1>
    <p>
    <pre>
        Free
        Open Source
        Cross Platform
        Development Platform
    </pre>

    <pre>
        <a href="https://dotnet.microsoft.com/en-us/" target="_blank">Download .Net => https://dotnet.microsoft.com/en-us/</a>
        <a href="https://learn.microsoft.com/en-us/dotnet/csharp/" target="_blank">Learn C# => https://learn.microsoft.com/en-us/dotnet/csharp/</a>
        <a href="https://learn.microsoft.com/en-us/aspnet/core/?view=aspnetcore-8.0" target="_blank">Learn ASP.NET => https://learn.microsoft.com/en-us/aspnet/core/?view=aspnetcore-8.0</a>
        <a href="https://github.com/dotnet" target="_blank">Github: https://github.com/dotnet</a>
        <a href="https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/tutorials/min-web-api/samples" target="_blank">Github Minimal API: https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/tutorials/min-web-api/samples</a>
        
        <b><a href="https://roadmap.sh/aspnet-core" target="_blank">Road Map ASP.NET developer => https://roadmap.sh/aspnet-core</a></b>

        <a href="https://www.tutorialsteacher.com/articles/difference-between-design-principle-and-design-pattern" target="_blank">Tutorials Teacher => Design Principle vs Design Pattern</a>
        <a href="https://www.javatpoint.com/c-sharp-tutorial" target="">C# tutorial => https://www.javatpoint.com/c-sharp-tutorial</a>

        <a href="https://www.linkedin.com/newsletters/dotnet-guru-7189522711310721025/" target="_blank">Linked In - Dotnet Guru Interview Preparation</a>
        
        https://www.scholarhat.com/tutorial/aspnet/asp-net-core-interview-questions
        https://capaciteam.com/top-software-design-patterns/
        https://www.tutorialsteacher.com/csharp
        https://www.scholarhat.com/tutorial/csharp/c-sharp-anonymous-method
        https://www.geeksforgeeks.org/csharp-programming-language/?ref=outind
        https://www.tutorialspoint.com/csharp/csharp_interview_questions.htm
        https://codeteddy.com/    
    </pre>

    <hr>
    <h3>Topics</h3>
    <ul>
        <li> Concepts
            <ul>
                <li>
                    <a href="https://www.linkedin.com/pulse/understanding-interfaces-dependency-injection-di-inversion-kamal-lxgwf/" target="_blank">
                        Understanding Interfaces, Dependency Injection (DI), and Dependency Inversion
                    </a>
                </li>
                <li>
                    <a href="https://www.linkedin.com/pulse/simplifying-asynchronousawait-net-step-by-step-guide-asharib-kamal-d9jvf/" target="_blank">
                        Simplifying Asynchronous/Await in .NET: A Step-by-Step Guide
                    </a>
                </li>
                <li>
                    <a href="https://www.linkedin.com/pulse/all-identity-server-comprehensive-guide-net-developers-asharib-kamal-snsaf/" target="_blank">
                        All About Identity Server: A Comprehensive Guide for .NET Developers
                    </a>
                </li>
                <li>
                    <a href="https://www.linkedin.com/pulse/understanding-dispose-vs-finalize-c-net-asharib-kamal-gndgf/" target="_blank">
                        Understanding Dispose vs. Finalize in C# .NET
                    </a>
                </li>
                <li>
                    <a href="https://www.linkedin.com/pulse/secure-your-aspnet-core-application-authentication-strategies-kamal-vkxif/" target="_blank">
                        Secure Your ASP.NET Core Application: Authentication and Authorization Strategies</a>           
                </li>
                <li>
                    <a href="https://www.linkedin.com/pulse/mastering-net-entity-framework-core-comprehensive-guide-asharib-kamal-x0fxc/" target="_blank">
                        Mastering .NET Entity Framework Core: A Comprehensive Guide
                    </a>
                </li>
                <li>
                    <a href="https://www.linkedin.com/pulse/clean-code-best-practices-advanced-c-asharib-kamal-5zysf/" target="_blank">
                        Clean code Best practices in advanced C#
                    </a>
                </li>
                <li>
                    <a href="https://www.linkedin.com/pulse/mastering-solid-principles-net-object-oriented-asharib-kamal-crgpf/" target="_blank">
                        Mastering SOLID Principles in .NET Object-Oriented Programming
                    </a>
                </li>
                <li>
                    <a href="https://www.linkedin.com/pulse/solid-principles-asharib-kamal-u3mnf/" target="_blank">
                        The SOLID principles
                    </a>
                </li>
                <li>
                    <a href="https://www.linkedin.com/pulse/design-patterns-c-net-comprehensive-guide-asharib-kamal-37q9f/" target="_blank">
                        Design Patterns in C# .NET: A Comprehensive Guide
                    </a>
                </li>
                <li>
                    <a href="https://www.linkedin.com/pulse/all-repository-pattern-c-net-asharib-kamal-2self/" target="_blank">
                        All About Repository Pattern in C# .NET
                    </a>
                </li>
                <li>
                    <a href="https://www.linkedin.com/pulse/clean-architecture-c-net-asharib-kamal-lqjsc/" target="_blank">
                        Clean Architecture in C# .NET
                    </a>
                </li>
                <li>
                    <a href="https://www.linkedin.com/pulse/implementing-microservices-architecture-net-core-practical-kamal-o7yhc/" target="_blank">
                        Microservice Architecture
                    </a>
                </li>
                <li>
                    <a href="https://www.linkedin.com/pulse/guide-sql-bulk-insert-net-asharib-kamal-dxnkf/" target="_blank">
                        A Guide to SQL Bulk Insert in .NET
                    </a>
                </li>
            </ul>
        </li>
        <li> Interview related
            <ul>
                <li>
                    <a href="https://www.linkedin.com/pulse/c-dot-net-interview-preparation-part-5-top-6-frequently-asharib-kamal-3y2yc/" target="_blank">
                        C# Dot Net Interview Preparation Part 5
                    </a>
                </li>
                <li>
                    <a href="https://www.linkedin.com/pulse/c-dot-net-interview-preparation-part-4-top-6-frequently-asharib-kamal-ajkbf/" target="_blank">
                        C# Dot Net Interview Preparation Part 4
                    </a>
                </li>
                <li>
                    <a href="https://www.linkedin.com/pulse/top-6-frequently-asked-interview-questions-answers-c-dot-kamal-wsirf/" target="_blank">
                        C# Dot Net Interview Preparation Part3
                    </a>
                </li>
                <li>
                    <a href="https://www.linkedin.com/pulse/c-dot-net-interview-preparation-part-2-top-6-frequently-asharib-kamal-lexpf/" target="_blank">
                        C# Dot Net Interview Preparation Part 2 
                    </a>
                </li>
                <li>
                    <a href="https://www.linkedin.com/pulse/c-dot-net-interview-preparation-part-1-asharib-kamal-zfdpf/" target="_blank">
                        C# Dot Net Interview Preparation Part 1
                    </a>
                </li>
                <li>
                    <a href="https://www.linkedin.com/pulse/interview-tips-net-developers-common-questions-how-answer-kamal-nf3jf/" target="_blank">
                        Interview Tips for .NET Developers: Common Questions and How to Answer Them
                    </a>                    
                </li>
                <li>
                    <a href="https://www.linkedin.com/pulse/top-net-interview-questions-how-ace-them-asharib-kamal-mcnwf/" target="_blank">
                        Top .NET Interview Questions
                    </a>
                </li>
                <li>
                    <a href="https://www.linkedin.com/pulse/coding-challenges-assessment-interview-questions-net-developers-5d3vf/" target="_blank">
                        Coding Challenges and Assessment Interview Questions for .NET Developers
                    </a>
                </li>
            </ul>            
        </li>
        <li>
            <a href="https://www.linkedin.com/pulse/assignment-programming-python-ict-100-murdoch-simple-banking-kamal-6jydf/" target="_blank">
                Assignment – Programming in Python ICT-100 @ Murdoch A Simple Banking Application Python
            </a>
        </li>
        <li>
            <a href="https://www.linkedin.com/pulse/top-best-22-net-content-creators-asharib-kamal-cbpvf/" target="_blank">
                Top Best (22) .NET Content Creators
            </a>
        </li>        
    </ul>

    <hr>

    <h3>ASP.NET core advanced concepts</h3>
    <pre>
        ASP.NET Core has a wealth of advanced features for building scalable, secure, and high-performance web applications. 
        Here’s a look at some advanced concepts and techniques you might find useful:

        ### 1. **Middleware Pipeline Customization**
           - Middleware is a crucial part of ASP.NET Core’s request/response pipeline. Custom middleware allows you to 
           handle requests and responses in a specific order. Using `app.Use` to create custom middleware can optimize your pipeline, 
           handle authentication, logging, and more.
           - **Tip**: Middleware can short-circuit requests or execute conditional logic based on user roles, performance optimizations, etc.
            
        ### 2. **Dependency Injection and Scoped Services**
           - ASP.NET Core has built-in support for dependency injection (DI), which is integral to building testable and maintainable code. 
           You can configure dependencies as singleton, scoped, or transient.
           - **Advanced Usage**: Use factory methods in DI for complex dependencies or inject services based on runtime parameters.
            
        ### 3. **Asynchronous Programming and I/O Optimization**
           - Using async/await effectively is critical for scalability in ASP.NET Core. Asynchronous programming is particularly 
           essential for handling large numbers of concurrent requests without blocking threads.
           - **Tip**: Leverage `IAsyncEnumerable` in streaming scenarios to handle large datasets efficiently.
            
        ### 4. **Background Tasks with Hosted Services**
           - Background services using `IHostedService` or `BackgroundService` allow you to perform tasks outside the request pipeline, 
           such as scheduled jobs, data synchronization, or message processing.
           - **Examples**: Use Hosted Services with the `QueueBackgroundWorkItem` method or create a custom task queue for processing 
           background jobs.
            
        ### 5. **Health Checks and Monitoring**
           - ASP.NET Core offers a robust health-check framework to monitor the status of services, database connectivity, 
           and other application components. This is crucial for microservices or containerized deployments.
           - **Tip**: Combine health checks with monitoring tools like Prometheus, Grafana, or Azure Monitor to track your 
           application’s health over time.
            
        ### 6. **Using gRPC for High-Performance Communication**
           - gRPC (Google Remote Procedure Calls) offers a faster, more efficient way to communicate between services compared to REST. 
           It’s ideal for microservices due to its low latency and binary format.
           - **Advanced Tip**: Configure gRPC with streaming capabilities or use gRPC-Web for communication between browser-based 
           applications and gRPC services.
            
        ### 7. **Authentication and Authorization with Policies and Claims**
           - ASP.NET Core provides robust authentication and authorization options, including JWT, OAuth, and OpenID Connect. 
           With policies and claims, you can create highly granular access control.
           - **Tip**: Use custom policies and claim transformations to manage user roles and permissions dynamically.
            
        ### 8. **Advanced Caching Techniques**
           - ASP.NET Core supports in-memory, distributed caching (e.g., Redis), and response caching to improve performance. 
           You can implement layered caching to minimize data retrieval times, especially for data-intensive applications.
           - **Tip**: Use `OutputCache` in ASP.NET Core 8 to enhance response caching based on URL, headers, or request properties.
            
        ### 9. **SignalR for Real-Time Web Applications**
           - SignalR provides real-time communication capabilities using WebSockets, making it ideal for applications that require 
           instant feedback, such as chat apps or live dashboards.
           - **Advanced Usage**: Use backplane solutions (like Redis or Azure SignalR) to handle scaling for distributed systems, 
           enabling consistent real-time experiences across multiple servers.
            
        ### 10. **Minimal APIs and Microservices Architecture**
           - ASP.NET Core now supports Minimal APIs, offering a simpler, lightweight way to build APIs with less code, 
           making them perfect for microservices.
           - **Tip**: Use Minimal APIs to create fast, focused microservices with minimal boilerplate code. 
           Combine them with API Gateways like Ocelot to route and load-balance requests effectively.
            
        ### 11. **Custom Filters for Cross-Cutting Concerns**
           - Filters (e.g., Action Filters, Exception Filters) allow you to inject behavior at specific stages in the request pipeline.
           - **Advanced Usage**: Create custom filters to handle common concerns like logging, exception handling, validation, 
           or even custom caching policies.
            
        ### 12. **Unit Testing and Integration Testing**
           - Advanced testing in ASP.NET Core can include unit testing with dependency injection, mocking, and integration testing 
           of complex services.
           - **Tip**: Use `WebApplicationFactory` for integration tests, and leverage `InMemory` or SQLite providers to test 
           database interactions without needing a real database.
            
        ### 13. **Secure Data with Data Protection APIs**
           - The Data Protection API in ASP.NET Core enables encryption and secure data storage. This is crucial for 
           securing sensitive information like tokens, session data, or cookies.
           - **Advanced Usage**: Implement custom key management and rotate keys periodically, or use an external key 
           storage solution like Azure Key Vault.
            
        ### 14. **Globalization and Localization**
           - ASP.NET Core provides built-in support for globalization and localization to create applications that can reach a global audience.
           - **Advanced Usage**: Customize resource file formats and leverage client-side localization with JavaScript to 
           create seamless multilingual experiences.
            
        ### 15. **Performance Profiling and Diagnostics with Diagnostic Source and ETW**
           - Profiling and diagnostics can be managed via `DiagnosticSource` for low-level event tracking. Events can also 
           be exported to ETW (Event Tracing for Windows) for real-time monitoring.
           - **Tip**: Combine with Application Insights or OpenTelemetry to build a comprehensive observability strategy.
            
        ### Additional Topics:
           - **CQRS and MediatR** for separating read and write operations.
           - **Docker and Kubernetes for Containerization** to streamline deployment and manage scaling.
           - **API Rate Limiting and Throttling** using middleware to protect resources from overuse.
    </pre>

    <hr>

    <pre>
        In ASP.NET Core, `app.Use` and `app.Run` are two methods for configuring the middleware pipeline, which processes each HTTP request as it moves through the application. Here’s how each of these methods works and their differences:

        ### `app.Use`
        - `app.Use` is a method to register middleware components that can perform operations on incoming HTTP requests and outgoing responses.
        - It allows you to pass the request to the next middleware in the pipeline by calling `next()` (or `await next()` in asynchronous middleware).
        - Middleware registered with `app.Use` can decide whether to pass control to the next middleware or short-circuit the pipeline and handle the request entirely within that middleware.

        #### Example:
        ```csharp
        app.Use(async (context, next) =>
        {
            // Log or modify the request
            Console.WriteLine("Before next middleware");
        
            // Call the next middleware in the pipeline
            await next();
        
            // Log or modify the response
            Console.WriteLine("After next middleware");
        });
        ```

        - Here, the first middleware logs "Before next middleware" before the next middleware is called and "After next middleware" after it completes.
        - This feature is useful for cross-cutting concerns like logging, authentication, authorization, etc., as you can take action before or after the request proceeds further.

        ### `app.Run`
        - `app.Run` is used to register terminal middleware, which means it is the last middleware in the pipeline for a specific request. Once `app.Run` executes, no further middleware will be called.
        - Unlike `app.Use`, `app.Run` does not call `next()`; it completely handles the request and ends the pipeline there.
        - Typically, you would use `app.Run` for final handling of requests, such as in cases where you have specific routes or conditions that need a dedicated response.

        #### Example:
        ```csharp
        app.Run(async context =>
        {
            // This middleware will end the request pipeline
            await context.Response.WriteAsync("Hello from app.Run!");
        });
        ```

        - Since there’s no `next()` in `app.Run`, the request pipeline stops at this middleware, and the response "Hello from app.Run!" is returned directly to the client.

        ### **Key Differences between `app.Use` and `app.Run`**
        - **Pipeline Continuation**: `app.Use` can pass control to the next middleware by calling `next()`, while `app.Run` does not, acting as a terminal middleware.
        - **Typical Use Case**: `app.Use` is for middleware that needs to perform work before and/or after subsequent middlewares, while `app.Run` is for scenarios where a request should be handled completely without moving further in the pipeline.

        ### Example Scenario
        Here’s an example of `app.Use` and `app.Run` working together in a pipeline:

        ```csharp
        app.Use(async (context, next) =>
        {
            Console.WriteLine("Middleware 1: Before next()");
            await next();
            Console.WriteLine("Middleware 1: After next()");
        });

        app.Use(async (context, next) =>
        {
            Console.WriteLine("Middleware 2: Before next()");
            await next();
            Console.WriteLine("Middleware 2: After next()");
        });

        app.Run(async context =>
        {
            // This middleware is terminal, no further middleware will be called.
            Console.WriteLine("Handling request in terminal middleware.");
            await context.Response.WriteAsync("Hello from terminal middleware!");
        });
        ```

        In this scenario:
        1. The request hits **Middleware 1**, logs "Before next()", and calls `next()`.
        2. Then **Middleware 2** logs "Before next()" and calls `next()`.
        3. Finally, it reaches the `app.Run` middleware, which handles the request and ends the pipeline.
        4. As the pipeline unwinds, "After next()" messages are logged by Middleware 2 and Middleware 1.

        Understanding `app.Use` and `app.Run` is key to configuring the ASP.NET Core middleware pipeline effectively, 
        giving you fine-grained control over request processing.
    </pre>

    <h3>Synchronous vs. Asynchronous Summary</h3>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Synchronous</th>
                <th>Asynchronous</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Execution Order</td>
                <td>One task at a time (sequential)</td>
                <td>Tasks can run concurrently in the background</td>
            </tr>
            <tr>
                <td>Responsiveness</td>
                <td>May block the main thread, causing lag</td>
                <td>Keeps the program responsive during long operations</td>
            </tr>
            <tr>
                <td>Complexity</td>
                <td>Simpler, straightforward</td>
                <td>Requires <code>async</code> and <code>await</code></td>
            </tr>
            <tr>
                <td>Example Scenarios</td>
                <td>CPU-bound tasks (calculations)</td>
                <td>I/O-bound tasks (file/network/database)</td>
            </tr>
        </tbody>
    </table>

    <br>
    <br>
    <b>Why Async/Await Isn't the Same as Synchronous Code</b>
    <br>
    While async and await may appear to behave like synchronous programming due to the linear,
    readable flow, they are fundamentally different in how they handle tasks and system resources.
    Let's delve into why this is the case and how async/await is distinct from synchronous programming

    <br>
    <br>
    async/await has a similar flow to synchronous code, it’s fundamentally different due to its non-blocking nature
    and efficient thread management, especially valuable in keeping applications responsive

    <br>
    <hr>
    <h3>
        These advanced asynchronous techniques can significantly enhance performance in .NET applications,
        especially in high-throughput, concurrent, or I/O-bound scenarios:
    </h3>

    <pre>
            Use Task.WhenAll for concurrent tasks
            Control concurrency with SemaphoreSlim
            Use ValueTask for frequent short-lived tasks
            Reduce async overhead in hot paths
            Use ConfigureAwait(false) in library code
            Manage producer-consumer workflows with Channel<T>
            Batch and reuse resources with ArrayPool<T>
            Use IAsyncEnumerable for efficient streaming of large datasets        
        </pre>

    <hr>

    </p>
</body>

</html>